{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\projects\\\\app-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport React from 'react';\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar renderErr = 'Renderer Error ‚òùÔ∏è';\nvar actions = {\n  init: 'init'\n};\nvar defaultColumn = {\n  Cell: function Cell(_ref) {\n    var _ref$cell$value = _ref.cell.value,\n        value = _ref$cell$value === void 0 ? '' : _ref$cell$value;\n    return value;\n  },\n  width: 150,\n  minWidth: 0,\n  maxWidth: Number.MAX_SAFE_INTEGER\n};\n\nfunction defaultOrderByFn(arr, funcs, dirs) {\n  return [].concat(arr).sort(function (rowA, rowB) {\n    for (var i = 0; i < funcs.length; i += 1) {\n      var sortFn = funcs[i];\n      var desc = dirs[i] === false || dirs[i] === 'desc';\n      var sortInt = sortFn(rowA, rowB);\n\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt;\n      }\n    }\n\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;\n  });\n}\n\nfunction defaultGroupByFn(rows, columnId) {\n  return rows.reduce(function (prev, row, i) {\n    // TODO: Might want to implement a key serializer here so\n    // irregular column values can still be grouped if needed?\n    var resKey = \"\" + row.values[columnId];\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];\n    prev[resKey].push(row);\n    return prev;\n  }, {});\n}\n\nfunction mergeProps() {\n  for (var _len = arguments.length, propList = new Array(_len), _key = 0; _key < _len; _key++) {\n    propList[_key] = arguments[_key];\n  }\n\n  return propList.reduce(function (props, next) {\n    var style = next.style,\n        className = next.className,\n        rest = _objectWithoutPropertiesLoose(next, [\"style\", \"className\"]);\n\n    props = _extends({}, props, {}, rest);\n\n    if (style) {\n      props.style = props.style ? _extends({}, props.style || {}, {}, style || {}) : style;\n    }\n\n    if (className) {\n      props.className = props.className ? props.className + ' ' + className : className;\n    }\n\n    if (props.className === '') {\n      delete props.className;\n    }\n\n    return props;\n  }, {});\n}\n\nfunction handlePropGetter(prevProps, userProps, meta) {\n  // Handle a lambda, pass it the previous props\n  if (typeof userProps === 'function') {\n    return handlePropGetter({}, userProps(prevProps, meta));\n  } // Handle an array, merge each item as separate props\n\n\n  if (Array.isArray(userProps)) {\n    return mergeProps.apply(void 0, [prevProps].concat(userProps));\n  } // Handle an object by default, merge the two objects\n\n\n  return mergeProps(prevProps, userProps);\n}\n\nvar makePropGetter = function makePropGetter(hooks, meta) {\n  if (meta === void 0) {\n    meta = {};\n  }\n\n  return function (userProps) {\n    if (userProps === void 0) {\n      userProps = {};\n    }\n\n    return [].concat(hooks, [userProps]).reduce(function (prev, next) {\n      return handlePropGetter(prev, next, _extends({}, meta, {\n        userProps: userProps\n      }));\n    }, {});\n  };\n};\n\nvar reduceHooks = function reduceHooks(hooks, initial, meta, allowUndefined) {\n  if (meta === void 0) {\n    meta = {};\n  }\n\n  return hooks.reduce(function (prev, next) {\n    var nextValue = next(prev, meta);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!allowUndefined && typeof nextValue === 'undefined') {\n        console.info(next);\n        throw new Error('React Table: A reducer hook ‚òùÔ∏è just returned undefined! This is not allowed.');\n      }\n    }\n\n    return nextValue;\n  }, initial);\n};\n\nvar loopHooks = function loopHooks(hooks, context, meta) {\n  if (meta === void 0) {\n    meta = {};\n  }\n\n  return hooks.forEach(function (hook) {\n    var nextValue = hook(context, meta);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof nextValue !== 'undefined') {\n        console.info(hook, nextValue);\n        throw new Error('React Table: A loop-type hook ‚òùÔ∏è just returned a value! This is not allowed.');\n      }\n    }\n  });\n};\n\nfunction ensurePluginOrder(plugins, befores, pluginName, afters) {\n  if (process.env.NODE_ENV !== 'production' && afters) {\n    throw new Error(\"Defining plugins in the \\\"after\\\" section of ensurePluginOrder is no longer supported (see plugin \" + pluginName + \")\");\n  }\n\n  var pluginIndex = plugins.findIndex(function (plugin) {\n    return plugin.pluginName === pluginName;\n  });\n\n  if (pluginIndex === -1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\"The plugin \\\"\" + pluginName + \"\\\" was not found in the plugin list!\\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\\n\\n  \" + pluginName + \".pluginName = '\" + pluginName + \"'\\n\");\n    }\n  }\n\n  befores.forEach(function (before) {\n    var beforeIndex = plugins.findIndex(function (plugin) {\n      return plugin.pluginName === before;\n    });\n\n    if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\"React Table: The \" + pluginName + \" plugin hook must be placed after the \" + before + \" plugin hook!\");\n      }\n    }\n  });\n}\n\nfunction functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater;\n}\n\nfunction useGetLatest(obj) {\n  var ref = React.useRef();\n  ref.current = obj;\n  return React.useCallback(function () {\n    return ref.current;\n  }, []);\n} // SSR has issues with useLayoutEffect still, so use useEffect during SSR\n\n\nvar safeUseLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction useMountedLayoutEffect(fn, deps) {\n  var mountedRef = React.useRef(false);\n  safeUseLayoutEffect(function () {\n    if (mountedRef.current) {\n      fn();\n    }\n\n    mountedRef.current = true; // eslint-disable-next-line\n  }, deps);\n}\n\nfunction useAsyncDebounce(defaultFn, defaultWait) {\n  if (defaultWait === void 0) {\n    defaultWait = 0;\n  }\n\n  var debounceRef = React.useRef({});\n  var getDefaultFn = useGetLatest(defaultFn);\n  var getDefaultWait = useGetLatest(defaultWait);\n  return React.useCallback(\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      var _len2,\n          args,\n          _key2,\n          _args2 = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              for (_len2 = _args2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = _args2[_key2];\n              }\n\n              if (!debounceRef.current.promise) {\n                debounceRef.current.promise = new Promise(function (resolve, reject) {\n                  debounceRef.current.resolve = resolve;\n                  debounceRef.current.reject = reject;\n                });\n              }\n\n              if (debounceRef.current.timeout) {\n                clearTimeout(debounceRef.current.timeout);\n              }\n\n              debounceRef.current.timeout = setTimeout(\n              /*#__PURE__*/\n              _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        delete debounceRef.current.timeout;\n                        _context.prev = 1;\n                        _context.t0 = debounceRef.current;\n                        _context.next = 5;\n                        return getDefaultFn().apply(void 0, args);\n\n                      case 5:\n                        _context.t1 = _context.sent;\n\n                        _context.t0.resolve.call(_context.t0, _context.t1);\n\n                        _context.next = 12;\n                        break;\n\n                      case 9:\n                        _context.prev = 9;\n                        _context.t2 = _context[\"catch\"](1);\n                        debounceRef.current.reject(_context.t2);\n\n                      case 12:\n                        _context.prev = 12;\n                        delete debounceRef.current.promise;\n                        return _context.finish(12);\n\n                      case 15:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 9, 12, 15]]);\n              })), getDefaultWait());\n              return _context2.abrupt(\"return\", debounceRef.current.promise);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function () {\n      return _ref2.apply(this, arguments);\n    };\n  }(), [getDefaultFn, getDefaultWait]);\n}\n\nfunction makeRenderer(instance, column, meta) {\n  if (meta === void 0) {\n    meta = {};\n  }\n\n  return function (type, userProps) {\n    if (userProps === void 0) {\n      userProps = {};\n    }\n\n    var Comp = typeof type === 'string' ? column[type] : type;\n\n    if (typeof Comp === 'undefined') {\n      console.info(column);\n      throw new Error(renderErr);\n    }\n\n    return flexRender(Comp, _extends({}, instance, {\n      column: column\n    }, meta, {}, userProps));\n  };\n}\n\nfunction flexRender(Comp, props) {\n  return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;\n}\n\nfunction isClassComponent(component) {\n  return typeof component === 'function' && !!function () {\n    var proto = Object.getPrototypeOf(component);\n    return proto.prototype && proto.prototype.isReactComponent;\n  }();\n}\n\nfunction isFunctionComponent(component) {\n  return typeof component === 'function';\n}\n\nfunction isExoticComponent(component) {\n  return typeof component === 'object' && typeof component.$$typeof === 'symbol' && ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description);\n}\n\nfunction isReactComponent(component) {\n  return isClassComponent(component) || isFunctionComponent(component) || isExoticComponent(component);\n}\n\nfunction linkColumnStructure(columns, parent, depth) {\n  if (depth === void 0) {\n    depth = 0;\n  }\n\n  return columns.map(function (column) {\n    column = _extends({}, column, {\n      parent: parent,\n      depth: depth\n    });\n    assignColumnAccessor(column);\n\n    if (column.columns) {\n      column.columns = linkColumnStructure(column.columns, column, depth + 1);\n    }\n\n    return column;\n  });\n}\n\nfunction flattenColumns(columns) {\n  return flattenBy(columns, 'columns');\n}\n\nfunction assignColumnAccessor(column) {\n  // First check for string accessor\n  var id = column.id,\n      accessor = column.accessor,\n      Header = column.Header;\n\n  if (typeof accessor === 'string') {\n    id = id || accessor;\n    var accessorPath = accessor.split('.');\n\n    accessor = function accessor(row) {\n      return getBy(row, accessorPath);\n    };\n  }\n\n  if (!id && typeof Header === 'string' && Header) {\n    id = Header;\n  }\n\n  if (!id && column.columns) {\n    console.error(column);\n    throw new Error('A column ID (or unique \"Header\" value) is required!');\n  }\n\n  if (!id) {\n    console.error(column);\n    throw new Error('A column ID (or string accessor) is required!');\n  }\n\n  Object.assign(column, {\n    id: id,\n    accessor: accessor\n  });\n  return column;\n} // Find the depth of the columns\n\n\nfunction dedupeBy(arr, fn) {\n  return [].concat(arr).reverse().filter(function (d, i, all) {\n    return all.findIndex(function (dd) {\n      return fn(dd) === fn(d);\n    }) === i;\n  }).reverse();\n}\n\nfunction decorateColumn(column, userDefaultColumn) {\n  if (!userDefaultColumn) {\n    throw new Error();\n  }\n\n  Object.assign(column, _extends({\n    // Make sure there is a fallback header, just in case\n    Header: function Header() {\n      return React.createElement(React.Fragment, null, \"\\xA0\");\n    },\n    Footer: function Footer() {\n      return React.createElement(React.Fragment, null, \"\\xA0\");\n    }\n  }, defaultColumn, {}, userDefaultColumn, {}, column));\n  return column;\n} // Build the header groups from the bottom up\n\n\nfunction makeHeaderGroups(allColumns, defaultColumn) {\n  var headerGroups = [];\n  var scanColumns = allColumns;\n  var uid = 0;\n\n  var getUID = function getUID() {\n    return uid++;\n  };\n\n  var _loop = function _loop() {\n    // The header group we are creating\n    var headerGroup = {\n      headers: []\n    }; // The parent columns we're going to scan next\n\n    var parentColumns = [];\n    var hasParents = scanColumns.some(function (d) {\n      return d.parent;\n    }); // Scan each column for parents\n\n    scanColumns.forEach(function (column) {\n      // What is the latest (last) parent column?\n      var latestParentColumn = [].concat(parentColumns).reverse()[0];\n      var newParent;\n\n      if (hasParents) {\n        // If the column has a parent, add it if necessary\n        if (column.parent) {\n          newParent = _extends({}, column.parent, {\n            originalId: column.parent.id,\n            id: column.parent.id + \"_\" + getUID(),\n            headers: [column]\n          });\n        } else {\n          // If other columns have parents, we'll need to add a place holder if necessary\n          var originalId = column.id + \"_placeholder\";\n          newParent = decorateColumn({\n            originalId: originalId,\n            id: column.id + \"_placeholder_\" + getUID(),\n            placeholderOf: column,\n            headers: [column]\n          }, defaultColumn);\n        } // If the resulting parent columns are the same, just add\n        // the column and increment the header span\n\n\n        if (latestParentColumn && latestParentColumn.originalId === newParent.originalId) {\n          latestParentColumn.headers.push(column);\n        } else {\n          parentColumns.push(newParent);\n        }\n      }\n\n      headerGroup.headers.push(column);\n    });\n    headerGroups.push(headerGroup); // Start scanning the parent columns\n\n    scanColumns = parentColumns;\n  };\n\n  while (scanColumns.length) {\n    _loop();\n  }\n\n  return headerGroups.reverse();\n}\n\nvar pathObjCache = new Map();\n\nfunction getBy(obj, path, def) {\n  if (!path) {\n    return obj;\n  }\n\n  var cacheKey = typeof path === 'function' ? path : JSON.stringify(path);\n\n  var pathObj = pathObjCache.get(cacheKey) || function () {\n    var pathObj = makePathArray(path);\n    pathObjCache.set(cacheKey, pathObj);\n    return pathObj;\n  }();\n\n  var val;\n\n  try {\n    val = pathObj.reduce(function (cursor, pathPart) {\n      return cursor[pathPart];\n    }, obj);\n  } catch (e) {// continue regardless of error\n  }\n\n  return typeof val !== 'undefined' ? val : def;\n}\n\nfunction getFirstDefined() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  for (var i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i];\n    }\n  }\n}\n\nfunction isFunction(a) {\n  if (typeof a === 'function') {\n    return a;\n  }\n}\n\nfunction flattenBy(arr, key) {\n  var flat = [];\n\n  var recurse = function recurse(arr) {\n    arr.forEach(function (d) {\n      if (!d[key]) {\n        flat.push(d);\n      } else {\n        recurse(d[key]);\n      }\n    });\n  };\n\n  recurse(arr);\n  return flat;\n}\n\nfunction expandRows(rows, _ref) {\n  var manualExpandedKey = _ref.manualExpandedKey,\n      expanded = _ref.expanded,\n      _ref$expandSubRows = _ref.expandSubRows,\n      expandSubRows = _ref$expandSubRows === void 0 ? true : _ref$expandSubRows;\n  var expandedRows = [];\n\n  var handleRow = function handleRow(row) {\n    row.isExpanded = row.original && row.original[manualExpandedKey] || expanded[row.id];\n    row.canExpand = row.subRows && !!row.subRows.length;\n    expandedRows.push(row);\n\n    if (expandSubRows && row.subRows && row.subRows.length && row.isExpanded) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n\n  rows.forEach(handleRow);\n  return expandedRows;\n}\n\nfunction getFilterMethod(filter, userFilterTypes, filterTypes) {\n  return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;\n}\n\nfunction shouldAutoRemoveFilter(autoRemove, value, column) {\n  return autoRemove ? autoRemove(value, column) : typeof value === 'undefined';\n}\n\nfunction unpreparedAccessWarning() {\n  throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');\n} //\n\n\nvar reOpenBracket = /\\[/g;\nvar reCloseBracket = /\\]/g;\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj) // remove all periods in parts\n  .map(function (d) {\n    return String(d).replace('.', '_');\n  }) // join parts using period\n  .join('.') // replace brackets with periods\n  .replace(reOpenBracket, '.').replace(reCloseBracket, '') // split it back out on periods\n  .split('.');\n}\n\nfunction flattenDeep(arr, newArr) {\n  if (newArr === void 0) {\n    newArr = [];\n  }\n\n  if (!Array.isArray(arr)) {\n    newArr.push(arr);\n  } else {\n    for (var i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr);\n    }\n  }\n\n  return newArr;\n}\n\nvar defaultGetTableProps = function defaultGetTableProps(props) {\n  return _extends({\n    role: 'table'\n  }, props);\n};\n\nvar defaultGetTableBodyProps = function defaultGetTableBodyProps(props) {\n  return _extends({\n    role: 'rowgroup'\n  }, props);\n};\n\nvar defaultGetHeaderProps = function defaultGetHeaderProps(props, _ref) {\n  var column = _ref.column;\n  return _extends({\n    key: \"header_\" + column.id,\n    colSpan: column.totalVisibleHeaderCount,\n    role: 'columnheader'\n  }, props);\n};\n\nvar defaultGetFooterProps = function defaultGetFooterProps(props, _ref2) {\n  var column = _ref2.column;\n  return _extends({\n    key: \"footer_\" + column.id,\n    colSpan: column.totalVisibleHeaderCount\n  }, props);\n};\n\nvar defaultGetHeaderGroupProps = function defaultGetHeaderGroupProps(props, _ref3) {\n  var index = _ref3.index;\n  return _extends({\n    key: \"headerGroup_\" + index,\n    role: 'row'\n  }, props);\n};\n\nvar defaultGetFooterGroupProps = function defaultGetFooterGroupProps(props, _ref4) {\n  var index = _ref4.index;\n  return _extends({\n    key: \"footerGroup_\" + index\n  }, props);\n};\n\nvar defaultGetRowProps = function defaultGetRowProps(props, _ref5) {\n  var row = _ref5.row;\n  return _extends({\n    key: \"row_\" + row.id,\n    role: 'row'\n  }, props);\n};\n\nvar defaultGetCellProps = function defaultGetCellProps(props, _ref6) {\n  var cell = _ref6.cell;\n  return _extends({\n    key: \"cell_\" + cell.row.id + \"_\" + cell.column.id,\n    role: 'cell'\n  }, props);\n};\n\nfunction makeDefaultPluginHooks() {\n  return {\n    useOptions: [],\n    stateReducers: [],\n    useControlledState: [],\n    columns: [],\n    columnsDeps: [],\n    allColumns: [],\n    allColumnsDeps: [],\n    accessValue: [],\n    materializedColumns: [],\n    materializedColumnsDeps: [],\n    useInstanceAfterData: [],\n    visibleColumns: [],\n    visibleColumnsDeps: [],\n    headerGroups: [],\n    headerGroupsDeps: [],\n    useInstanceBeforeDimensions: [],\n    useInstance: [],\n    prepareRow: [],\n    getTableProps: [defaultGetTableProps],\n    getTableBodyProps: [defaultGetTableBodyProps],\n    getHeaderGroupProps: [defaultGetHeaderGroupProps],\n    getFooterGroupProps: [defaultGetFooterGroupProps],\n    getHeaderProps: [defaultGetHeaderProps],\n    getFooterProps: [defaultGetFooterProps],\n    getRowProps: [defaultGetRowProps],\n    getCellProps: [defaultGetCellProps],\n    useFinalInstance: []\n  };\n}\n\nactions.resetHiddenColumns = 'resetHiddenColumns';\nactions.toggleHideColumn = 'toggleHideColumn';\nactions.setHiddenColumns = 'setHiddenColumns';\nactions.toggleHideAllColumns = 'toggleHideAllColumns';\n\nvar useColumnVisibility = function useColumnVisibility(hooks) {\n  hooks.getToggleHiddenProps = [defaultGetToggleHiddenProps];\n  hooks.getToggleHideAllColumnsProps = [defaultGetToggleHideAllColumnsProps];\n  hooks.stateReducers.push(reducer);\n  hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions);\n  hooks.headerGroupsDeps.push(function (deps, _ref) {\n    var instance = _ref.instance;\n    return [].concat(deps, [instance.state.hiddenColumns]);\n  });\n  hooks.useInstance.push(useInstance);\n};\n\nuseColumnVisibility.pluginName = 'useColumnVisibility';\n\nvar defaultGetToggleHiddenProps = function defaultGetToggleHiddenProps(props, _ref2) {\n  var column = _ref2.column;\n  return [props, {\n    onChange: function onChange(e) {\n      column.toggleHidden(!e.target.checked);\n    },\n    style: {\n      cursor: 'pointer'\n    },\n    checked: column.isVisible,\n    title: 'Toggle Column Visible'\n  }];\n};\n\nvar defaultGetToggleHideAllColumnsProps = function defaultGetToggleHideAllColumnsProps(props, _ref3) {\n  var instance = _ref3.instance;\n  return [props, {\n    onChange: function onChange(e) {\n      instance.toggleHideAllColumns(!e.target.checked);\n    },\n    style: {\n      cursor: 'pointer'\n    },\n    checked: !instance.allColumnsHidden && !instance.state.hiddenColumns.length,\n    title: 'Toggle All Columns Hidden',\n    indeterminate: !instance.allColumnsHidden && instance.state.hiddenColumns.length\n  }];\n};\n\nfunction reducer(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      hiddenColumns: []\n    }, state);\n  }\n\n  if (action.type === actions.resetHiddenColumns) {\n    return _extends({}, state, {\n      hiddenColumns: instance.initialState.hiddenColumns || []\n    });\n  }\n\n  if (action.type === actions.toggleHideColumn) {\n    var should = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.includes(action.columnId);\n    var hiddenColumns = should ? [].concat(state.hiddenColumns, [action.columnId]) : state.hiddenColumns.filter(function (d) {\n      return d !== action.columnId;\n    });\n    return _extends({}, state, {\n      hiddenColumns: hiddenColumns\n    });\n  }\n\n  if (action.type === actions.setHiddenColumns) {\n    return _extends({}, state, {\n      hiddenColumns: functionalUpdate(action.value, state.hiddenColumns)\n    });\n  }\n\n  if (action.type === actions.toggleHideAllColumns) {\n    var shouldAll = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.length;\n    return _extends({}, state, {\n      hiddenColumns: shouldAll ? instance.allColumns.map(function (d) {\n        return d.id;\n      }) : []\n    });\n  }\n}\n\nfunction useInstanceBeforeDimensions(instance) {\n  var headers = instance.headers,\n      hiddenColumns = instance.state.hiddenColumns;\n  var isMountedRef = React.useRef(false);\n  if (!isMountedRef.current) ;\n\n  var handleColumn = function handleColumn(column, parentVisible) {\n    column.isVisible = parentVisible && !hiddenColumns.includes(column.id);\n    var totalVisibleHeaderCount = 0;\n\n    if (column.headers && column.headers.length) {\n      column.headers.forEach(function (subColumn) {\n        return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);\n      });\n    } else {\n      totalVisibleHeaderCount = column.isVisible ? 1 : 0;\n    }\n\n    column.totalVisibleHeaderCount = totalVisibleHeaderCount;\n    return totalVisibleHeaderCount;\n  };\n\n  var totalVisibleHeaderCount = 0;\n  headers.forEach(function (subHeader) {\n    return totalVisibleHeaderCount += handleColumn(subHeader, true);\n  });\n}\n\nfunction useInstance(instance) {\n  var flatHeaders = instance.flatHeaders,\n      dispatch = instance.dispatch,\n      allColumns = instance.allColumns,\n      getHooks = instance.getHooks,\n      hiddenColumns = instance.state.hiddenColumns;\n  var getInstance = useGetLatest(instance);\n  var allColumnsHidden = allColumns.length === hiddenColumns.length;\n  var toggleHideColumn = React.useCallback(function (columnId, value) {\n    return dispatch({\n      type: actions.toggleHideColumn,\n      columnId: columnId,\n      value: value\n    });\n  }, [dispatch]);\n  var setHiddenColumns = React.useCallback(function (value) {\n    return dispatch({\n      type: actions.setHiddenColumns,\n      value: value\n    });\n  }, [dispatch]);\n  var toggleHideAllColumns = React.useCallback(function (value) {\n    return dispatch({\n      type: actions.toggleHideAllColumns,\n      value: value\n    });\n  }, [dispatch]);\n  var getToggleHideAllColumnsProps = makePropGetter(getHooks().getToggleHideAllColumnsProps, {\n    instance: getInstance()\n  });\n  flatHeaders.forEach(function (column) {\n    column.toggleHidden = function (value) {\n      dispatch({\n        type: actions.toggleHideColumn,\n        columnId: column.id,\n        value: value\n      });\n    };\n\n    column.getToggleHiddenProps = makePropGetter(getHooks().getToggleHiddenProps, {\n      instance: getInstance(),\n      column: column\n    });\n  });\n  Object.assign(instance, {\n    allColumnsHidden: allColumnsHidden,\n    toggleHideColumn: toggleHideColumn,\n    setHiddenColumns: setHiddenColumns,\n    toggleHideAllColumns: toggleHideAllColumns,\n    getToggleHideAllColumnsProps: getToggleHideAllColumnsProps\n  });\n}\n\nvar defaultInitialState = {};\nvar defaultColumnInstance = {};\n\nvar defaultReducer = function defaultReducer(state, action, prevState) {\n  return state;\n};\n\nvar defaultGetSubRows = function defaultGetSubRows(row, index) {\n  return row.subRows || [];\n};\n\nvar defaultGetRowId = function defaultGetRowId(row, index, parent) {\n  return \"\" + (parent ? [parent.id, index].join('.') : index);\n};\n\nvar defaultUseControlledState = function defaultUseControlledState(d) {\n  return d;\n};\n\nfunction applyDefaults(props) {\n  var _props$initialState = props.initialState,\n      initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState,\n      _props$defaultColumn = props.defaultColumn,\n      defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn,\n      _props$getSubRows = props.getSubRows,\n      getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows,\n      _props$getRowId = props.getRowId,\n      getRowId = _props$getRowId === void 0 ? defaultGetRowId : _props$getRowId,\n      _props$stateReducer = props.stateReducer,\n      stateReducer = _props$stateReducer === void 0 ? defaultReducer : _props$stateReducer,\n      _props$useControlledS = props.useControlledState,\n      useControlledState = _props$useControlledS === void 0 ? defaultUseControlledState : _props$useControlledS,\n      rest = _objectWithoutPropertiesLoose(props, [\"initialState\", \"defaultColumn\", \"getSubRows\", \"getRowId\", \"stateReducer\", \"useControlledState\"]);\n\n  return _extends({}, rest, {\n    initialState: initialState,\n    defaultColumn: defaultColumn,\n    getSubRows: getSubRows,\n    getRowId: getRowId,\n    stateReducer: stateReducer,\n    useControlledState: useControlledState\n  });\n}\n\nvar useTable = function useTable(props) {\n  for (var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    plugins[_key - 1] = arguments[_key];\n  } // Apply default props\n\n\n  props = applyDefaults(props); // Add core plugins\n\n  plugins = [useColumnVisibility].concat(plugins); // Create the table instance\n\n  var instanceRef = React.useRef({}); // Create a getter for the instance (helps avoid a lot of potential memory leaks)\n\n  var getInstance = useGetLatest(instanceRef.current); // Assign the props, plugins and hooks to the instance\n\n  Object.assign(getInstance(), _extends({}, props, {\n    plugins: plugins,\n    hooks: makeDefaultPluginHooks()\n  })); // Allow plugins to register hooks as early as possible\n\n  plugins.filter(Boolean).forEach(function (plugin) {\n    plugin(getInstance().hooks);\n  }); // Consume all hooks and make a getter for them\n\n  var getHooks = useGetLatest(getInstance().hooks);\n  getInstance().getHooks = getHooks;\n  delete getInstance().hooks; // Allow useOptions hooks to modify the options coming into the table\n\n  Object.assign(getInstance(), reduceHooks(getHooks().useOptions, applyDefaults(props)));\n\n  var _getInstance = getInstance(),\n      data = _getInstance.data,\n      userColumns = _getInstance.columns,\n      initialState = _getInstance.initialState,\n      defaultColumn = _getInstance.defaultColumn,\n      getSubRows = _getInstance.getSubRows,\n      getRowId = _getInstance.getRowId,\n      stateReducer = _getInstance.stateReducer,\n      useControlledState = _getInstance.useControlledState; // Setup user reducer ref\n\n\n  var getStateReducer = useGetLatest(stateReducer); // Build the reducer\n\n  var reducer = React.useCallback(function (state, action) {\n    // Detect invalid actions\n    if (!action.type) {\n      console.info({\n        action: action\n      });\n      throw new Error('Unknown Action üëÜ');\n    } // Reduce the state from all plugin reducers\n\n\n    return [].concat(getHooks().stateReducers, Array.isArray(getStateReducer()) ? getStateReducer() : [getStateReducer()]).reduce(function (s, handler) {\n      return handler(s, action, state, getInstance()) || s;\n    }, state);\n  }, [getHooks, getStateReducer, getInstance]); // Start the reducer\n\n  var _React$useReducer = React.useReducer(reducer, undefined, function () {\n    return reducer(initialState, {\n      type: actions.init\n    });\n  }),\n      reducerState = _React$useReducer[0],\n      dispatch = _React$useReducer[1]; // Allow the user to control the final state with hooks\n\n\n  var state = reduceHooks([].concat(getHooks().useControlledState, [useControlledState]), reducerState, {\n    instance: getInstance()\n  });\n  Object.assign(getInstance(), {\n    state: state,\n    dispatch: dispatch\n  }); // Decorate All the columns\n\n  var columns = React.useMemo(function () {\n    return linkColumnStructure(reduceHooks(getHooks().columns, userColumns, {\n      instance: getInstance()\n    }));\n  }, [getHooks, getInstance, userColumns].concat(reduceHooks(getHooks().columnsDeps, [], {\n    instance: getInstance()\n  })));\n  getInstance().columns = columns; // Get the flat list of all columns and allow hooks to decorate\n  // those columns (and trigger this memoization via deps)\n\n  var allColumns = React.useMemo(function () {\n    return reduceHooks(getHooks().allColumns, flattenColumns(columns), {\n      instance: getInstance()\n    }).map(assignColumnAccessor);\n  }, [columns, getHooks, getInstance].concat(reduceHooks(getHooks().allColumnsDeps, [], {\n    instance: getInstance()\n  })));\n  getInstance().allColumns = allColumns; // Access the row model using initial columns\n\n  var coreDataModel = React.useMemo(function () {\n    var rows = [];\n    var flatRows = [];\n    var rowsById = {};\n    var allColumnsQueue = [].concat(allColumns);\n\n    while (allColumnsQueue.length) {\n      var column = allColumnsQueue.shift();\n      accessRowsForColumn({\n        data: data,\n        rows: rows,\n        flatRows: flatRows,\n        rowsById: rowsById,\n        column: column,\n        getRowId: getRowId,\n        getSubRows: getSubRows,\n        accessValueHooks: getHooks().accessValue,\n        getInstance: getInstance\n      });\n    }\n\n    return {\n      rows: rows,\n      flatRows: flatRows,\n      rowsById: rowsById\n    };\n  }, [allColumns, data, getRowId, getSubRows, getHooks, getInstance]); // Allow materialized columns to also access data\n\n  var _React$useMemo = React.useMemo(function () {\n    var rows = coreDataModel.rows,\n        flatRows = coreDataModel.flatRows,\n        rowsById = coreDataModel.rowsById;\n    var materializedColumns = reduceHooks(getHooks().materializedColumns, [], {\n      instance: getInstance()\n    });\n    materializedColumns.forEach(function (d) {\n      return assignColumnAccessor(d);\n    });\n    var materializedColumnsQueue = [].concat(materializedColumns);\n\n    while (materializedColumnsQueue.length) {\n      var column = materializedColumnsQueue.shift();\n      accessRowsForColumn({\n        data: data,\n        rows: rows,\n        flatRows: flatRows,\n        rowsById: rowsById,\n        column: column,\n        getRowId: getRowId,\n        getSubRows: getSubRows,\n        accessValueHooks: getHooks().accessValue,\n        getInstance: getInstance\n      });\n    }\n\n    return [rows, flatRows, rowsById, materializedColumns];\n  }, [coreDataModel, getHooks, getInstance, data, getRowId, getSubRows].concat(reduceHooks(getHooks().materializedColumnsDeps, [], {\n    instance: getInstance()\n  }))),\n      rows = _React$useMemo[0],\n      flatRows = _React$useMemo[1],\n      rowsById = _React$useMemo[2],\n      materializedColumns = _React$useMemo[3];\n\n  Object.assign(getInstance(), {\n    rows: rows,\n    flatRows: flatRows,\n    rowsById: rowsById,\n    materializedColumns: materializedColumns\n  });\n  loopHooks(getHooks().useInstanceAfterData, getInstance()); // Combine new materialized columns with all columns (dedupe prefers later columns)\n\n  allColumns = React.useMemo(function () {\n    return dedupeBy([].concat(allColumns, materializedColumns), function (d) {\n      return d.id;\n    });\n  }, [allColumns, materializedColumns]);\n  getInstance().allColumns = allColumns; // Get the flat list of all columns AFTER the rows\n  // have been access, and allow hooks to decorate\n  // those columns (and trigger this memoization via deps)\n\n  var visibleColumns = React.useMemo(function () {\n    return reduceHooks(getHooks().visibleColumns, allColumns, {\n      instance: getInstance()\n    }).map(function (d) {\n      return decorateColumn(d, defaultColumn);\n    });\n  }, [getHooks, allColumns, getInstance, defaultColumn].concat(reduceHooks(getHooks().visibleColumnsDeps, [], {\n    instance: getInstance()\n  }))); // Combine new visible columns with all columns (dedupe prefers later columns)\n\n  allColumns = React.useMemo(function () {\n    return dedupeBy([].concat(allColumns, visibleColumns), function (d) {\n      return d.id;\n    });\n  }, [allColumns, visibleColumns]);\n  getInstance().allColumns = allColumns; // Make the headerGroups\n\n  var headerGroups = React.useMemo(function () {\n    return reduceHooks(getHooks().headerGroups, makeHeaderGroups(visibleColumns, defaultColumn), getInstance());\n  }, [getHooks, visibleColumns, defaultColumn, getInstance].concat(reduceHooks(getHooks().headerGroupsDeps, [], {\n    instance: getInstance()\n  })));\n  getInstance().headerGroups = headerGroups; // Get the first level of headers\n\n  var headers = React.useMemo(function () {\n    return headerGroups.length ? headerGroups[0].headers : [];\n  }, [headerGroups]);\n  getInstance().headers = headers; // Provide a flat header list for utilities\n\n  getInstance().flatHeaders = headerGroups.reduce(function (all, headerGroup) {\n    return [].concat(all, headerGroup.headers);\n  }, []);\n  loopHooks(getHooks().useInstanceBeforeDimensions, getInstance()); // Filter columns down to visible ones\n\n  var visibleColumnsDep = visibleColumns.filter(function (d) {\n    return d.isVisible;\n  }).map(function (d) {\n    return d.id;\n  }).sort().join('_');\n  visibleColumns = React.useMemo(function () {\n    return visibleColumns.filter(function (d) {\n      return d.isVisible;\n    });\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [visibleColumns, visibleColumnsDep]);\n  getInstance().visibleColumns = visibleColumns; // Header Visibility is needed by this point\n\n  var _calculateHeaderWidth = calculateHeaderWidths(headers),\n      totalColumnsMinWidth = _calculateHeaderWidth[0],\n      totalColumnsWidth = _calculateHeaderWidth[1],\n      totalColumnsMaxWidth = _calculateHeaderWidth[2];\n\n  getInstance().totalColumnsMinWidth = totalColumnsMinWidth;\n  getInstance().totalColumnsWidth = totalColumnsWidth;\n  getInstance().totalColumnsMaxWidth = totalColumnsMaxWidth;\n  loopHooks(getHooks().useInstance, getInstance()) // Each materialized header needs to be assigned a render function and other\n  // prop getter properties here.\n  ;\n  [].concat(getInstance().flatHeaders, getInstance().allColumns).forEach(function (column) {\n    // Give columns/headers rendering power\n    column.render = makeRenderer(getInstance(), column); // Give columns/headers a default getHeaderProps\n\n    column.getHeaderProps = makePropGetter(getHooks().getHeaderProps, {\n      instance: getInstance(),\n      column: column\n    }); // Give columns/headers a default getFooterProps\n\n    column.getFooterProps = makePropGetter(getHooks().getFooterProps, {\n      instance: getInstance(),\n      column: column\n    });\n  });\n  getInstance().headerGroups = getInstance().headerGroups.filter(function (headerGroup, i) {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(function (column) {\n      var recurse = function recurse(headers) {\n        return headers.filter(function (column) {\n          if (column.headers) {\n            return recurse(column.headers);\n          }\n\n          return column.isVisible;\n        }).length;\n      };\n\n      if (column.headers) {\n        return recurse(column.headers);\n      }\n\n      return column.isVisible;\n    }); // Give headerGroups getRowProps\n\n    if (headerGroup.headers.length) {\n      headerGroup.getHeaderGroupProps = makePropGetter(getHooks().getHeaderGroupProps, {\n        instance: getInstance(),\n        headerGroup: headerGroup,\n        index: i\n      });\n      headerGroup.getFooterGroupProps = makePropGetter(getHooks().getFooterGroupProps, {\n        instance: getInstance(),\n        headerGroup: headerGroup,\n        index: i\n      });\n      return true;\n    }\n\n    return false;\n  });\n  getInstance().footerGroups = [].concat(getInstance().headerGroups).reverse(); // The prepareRow function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n\n  getInstance().prepareRow = React.useCallback(function (row) {\n    row.getRowProps = makePropGetter(getHooks().getRowProps, {\n      instance: getInstance(),\n      row: row\n    }); // Build the visible cells for each row\n\n    row.allCells = allColumns.map(function (column) {\n      var cell = {\n        column: column,\n        row: row,\n        value: row.values[column.id]\n      }; // Give each cell a getCellProps base\n\n      cell.getCellProps = makePropGetter(getHooks().getCellProps, {\n        instance: getInstance(),\n        cell: cell\n      }); // Give each cell a renderer function (supports multiple renderers)\n\n      cell.render = makeRenderer(getInstance(), column, {\n        row: row,\n        cell: cell\n      });\n      return cell;\n    });\n    row.cells = visibleColumns.map(function (column) {\n      return row.allCells.find(function (cell) {\n        return cell.column.id === column.id;\n      });\n    }); // need to apply any row specific hooks (useExpanded requires this)\n\n    loopHooks(getHooks().prepareRow, row, {\n      instance: getInstance()\n    });\n  }, [getHooks, getInstance, allColumns, visibleColumns]);\n  getInstance().getTableProps = makePropGetter(getHooks().getTableProps, {\n    instance: getInstance()\n  });\n  getInstance().getTableBodyProps = makePropGetter(getHooks().getTableBodyProps, {\n    instance: getInstance()\n  });\n  loopHooks(getHooks().useFinalInstance, getInstance());\n  return getInstance();\n};\n\nfunction calculateHeaderWidths(headers, left) {\n  if (left === void 0) {\n    left = 0;\n  }\n\n  var sumTotalMinWidth = 0;\n  var sumTotalWidth = 0;\n  var sumTotalMaxWidth = 0;\n  var sumTotalFlexWidth = 0;\n  headers.forEach(function (header) {\n    var subHeaders = header.headers;\n    header.totalLeft = left;\n\n    if (subHeaders && subHeaders.length) {\n      var _calculateHeaderWidth2 = calculateHeaderWidths(subHeaders, left),\n          totalMinWidth = _calculateHeaderWidth2[0],\n          totalWidth = _calculateHeaderWidth2[1],\n          totalMaxWidth = _calculateHeaderWidth2[2],\n          totalFlexWidth = _calculateHeaderWidth2[3];\n\n      header.totalMinWidth = totalMinWidth;\n      header.totalWidth = totalWidth;\n      header.totalMaxWidth = totalMaxWidth;\n      header.totalFlexWidth = totalFlexWidth;\n    } else {\n      header.totalMinWidth = header.minWidth;\n      header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);\n      header.totalMaxWidth = header.maxWidth;\n      header.totalFlexWidth = header.canResize ? header.totalWidth : 0;\n    }\n\n    if (header.isVisible) {\n      left += header.totalWidth;\n      sumTotalMinWidth += header.totalMinWidth;\n      sumTotalWidth += header.totalWidth;\n      sumTotalMaxWidth += header.totalMaxWidth;\n      sumTotalFlexWidth += header.totalFlexWidth;\n    }\n  });\n  return [sumTotalMinWidth, sumTotalWidth, sumTotalMaxWidth, sumTotalFlexWidth];\n}\n\nfunction accessRowsForColumn(_ref) {\n  var data = _ref.data,\n      rows = _ref.rows,\n      flatRows = _ref.flatRows,\n      rowsById = _ref.rowsById,\n      column = _ref.column,\n      getRowId = _ref.getRowId,\n      getSubRows = _ref.getSubRows,\n      accessValueHooks = _ref.accessValueHooks,\n      getInstance = _ref.getInstance; // Access the row's data column-by-column\n  // We do it this way so we can incrementally add materialized\n  // columns after the first pass and avoid excessive looping\n\n  var accessRow = function accessRow(originalRow, rowIndex, depth, parent, parentRows) {\n    if (depth === void 0) {\n      depth = 0;\n    } // Keep the original reference around\n\n\n    var original = originalRow;\n    var id = getRowId(originalRow, rowIndex, parent);\n    var row = rowsById[id]; // If the row hasn't been created, let's make it\n\n    if (!row) {\n      row = {\n        id: id,\n        original: original,\n        index: rowIndex,\n        depth: depth,\n        cells: [{}] // This is a dummy cell\n\n      }; // Override common array functions (and the dummy cell's getCellProps function)\n      // to show an error if it is accessed without calling prepareRow\n\n      row.cells.map = unpreparedAccessWarning;\n      row.cells.filter = unpreparedAccessWarning;\n      row.cells.forEach = unpreparedAccessWarning;\n      row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values\n\n      row.values = {}; // Push this row into the parentRows array\n\n      parentRows.push(row); // Keep track of every row in a flat array\n\n      flatRows.push(row); // Also keep track of every row by its ID\n\n      rowsById[id] = row; // Get the original subrows\n\n      row.originalSubRows = getSubRows(originalRow, rowIndex); // Then recursively access them\n\n      if (row.originalSubRows) {\n        var subRows = [];\n        row.originalSubRows.forEach(function (d, i) {\n          return accessRow(d, i, depth + 1, row, subRows);\n        }); // Keep the new subRows array on the row\n\n        row.subRows = subRows;\n      }\n    } else if (row.subRows) {\n      // If the row exists, then it's already been accessed\n      // Keep recursing, but don't worry about passing the\n      // accumlator array (those rows already exist)\n      row.originalSubRows.forEach(function (d, i) {\n        return accessRow(d, i, depth + 1, row);\n      });\n    } // If the column has an accessor, use it to get a value\n\n\n    if (column.accessor) {\n      row.values[column.id] = column.accessor(originalRow, rowIndex, row);\n    } // Allow plugins to manipulate the column value\n\n\n    row.values[column.id] = reduceHooks(accessValueHooks, row.values[column.id], {\n      row: row,\n      column: column,\n      instance: getInstance()\n    }, true);\n  };\n\n  data.forEach(function (originalRow, rowIndex) {\n    return accessRow(originalRow, rowIndex, 0, undefined, rows);\n  });\n}\n\nactions.resetExpanded = 'resetExpanded';\nactions.toggleRowExpanded = 'toggleRowExpanded';\nactions.toggleAllRowsExpanded = 'toggleAllRowsExpanded';\n\nvar useExpanded = function useExpanded(hooks) {\n  hooks.getToggleAllRowsExpandedProps = [defaultGetToggleAllRowsExpandedProps];\n  hooks.getToggleRowExpandedProps = [defaultGetToggleRowExpandedProps];\n  hooks.stateReducers.push(reducer$1);\n  hooks.useInstance.push(useInstance$1);\n  hooks.prepareRow.push(prepareRow);\n};\n\nuseExpanded.pluginName = 'useExpanded';\n\nvar defaultGetToggleAllRowsExpandedProps = function defaultGetToggleAllRowsExpandedProps(props, _ref) {\n  var instance = _ref.instance;\n  return [props, {\n    onClick: function onClick(e) {\n      instance.toggleAllRowsExpanded();\n    },\n    style: {\n      cursor: 'pointer'\n    },\n    title: 'Toggle All Rows Expanded'\n  }];\n};\n\nvar defaultGetToggleRowExpandedProps = function defaultGetToggleRowExpandedProps(props, _ref2) {\n  var row = _ref2.row;\n  return [props, {\n    onClick: function onClick() {\n      row.toggleRowExpanded();\n    },\n    style: {\n      cursor: 'pointer'\n    },\n    title: 'Toggle Row Expanded'\n  }];\n}; // Reducer\n\n\nfunction reducer$1(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      expanded: {}\n    }, state);\n  }\n\n  if (action.type === actions.resetExpanded) {\n    return _extends({}, state, {\n      expanded: instance.initialState.expanded || {}\n    });\n  }\n\n  if (action.type === actions.toggleAllRowsExpanded) {\n    var value = action.value;\n    var isAllRowsExpanded = instance.isAllRowsExpanded,\n        rowsById = instance.rowsById;\n    var expandAll = typeof value !== 'undefined' ? value : !isAllRowsExpanded;\n\n    if (expandAll) {\n      var expanded = {};\n      Object.keys(rowsById).forEach(function (rowId) {\n        expanded[rowId] = true;\n      });\n      return _extends({}, state, {\n        expanded: expanded\n      });\n    }\n\n    return _extends({}, state, {\n      expanded: {}\n    });\n  }\n\n  if (action.type === actions.toggleRowExpanded) {\n    var id = action.id,\n        setExpanded = action.value;\n    var exists = state.expanded[id];\n    var shouldExist = typeof setExpanded !== 'undefined' ? setExpanded : !exists;\n\n    if (!exists && shouldExist) {\n      var _extends2;\n\n      return _extends({}, state, {\n        expanded: _extends({}, state.expanded, (_extends2 = {}, _extends2[id] = true, _extends2))\n      });\n    } else if (exists && !shouldExist) {\n      var _state$expanded = state.expanded,\n          _ = _state$expanded[id],\n          rest = _objectWithoutPropertiesLoose(_state$expanded, [id].map(_toPropertyKey));\n\n      return _extends({}, state, {\n        expanded: rest\n      });\n    } else {\n      return state;\n    }\n  }\n}\n\nfunction useInstance$1(instance) {\n  var data = instance.data,\n      rows = instance.rows,\n      rowsById = instance.rowsById,\n      _instance$manualExpan = instance.manualExpandedKey,\n      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n      _instance$paginateExp = instance.paginateExpandedRows,\n      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n      _instance$expandSubRo = instance.expandSubRows,\n      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n      _instance$autoResetEx = instance.autoResetExpanded,\n      autoResetExpanded = _instance$autoResetEx === void 0 ? true : _instance$autoResetEx,\n      getHooks = instance.getHooks,\n      plugins = instance.plugins,\n      expanded = instance.state.expanded,\n      dispatch = instance.dispatch;\n  ensurePluginOrder(plugins, ['useSortBy', 'useGroupBy', 'usePivotColumns', 'useGlobalFilter'], 'useExpanded');\n  var getAutoResetExpanded = useGetLatest(autoResetExpanded);\n  var isAllRowsExpanded = Boolean(Object.keys(rowsById).length && Object.keys(expanded).length);\n\n  if (isAllRowsExpanded) {\n    if (Object.keys(rowsById).some(function (id) {\n      return !expanded[id];\n    })) {\n      isAllRowsExpanded = false;\n    }\n  } // Bypass any effects from firing when this changes\n\n\n  useMountedLayoutEffect(function () {\n    if (getAutoResetExpanded()) {\n      dispatch({\n        type: actions.resetExpanded\n      });\n    }\n  }, [dispatch, data]);\n  var toggleRowExpanded = React.useCallback(function (id, value) {\n    dispatch({\n      type: actions.toggleRowExpanded,\n      id: id,\n      value: value\n    });\n  }, [dispatch]);\n  var toggleAllRowsExpanded = React.useCallback(function (value) {\n    return dispatch({\n      type: actions.toggleAllRowsExpanded,\n      value: value\n    });\n  }, [dispatch]);\n  var expandedRows = React.useMemo(function () {\n    if (paginateExpandedRows) {\n      return expandRows(rows, {\n        manualExpandedKey: manualExpandedKey,\n        expanded: expanded,\n        expandSubRows: expandSubRows\n      });\n    }\n\n    return rows;\n  }, [paginateExpandedRows, rows, manualExpandedKey, expanded, expandSubRows]);\n  var expandedDepth = React.useMemo(function () {\n    return findExpandedDepth(expanded);\n  }, [expanded]);\n  var getInstance = useGetLatest(instance);\n  var getToggleAllRowsExpandedProps = makePropGetter(getHooks().getToggleAllRowsExpandedProps, {\n    instance: getInstance()\n  });\n  Object.assign(instance, {\n    preExpandedRows: rows,\n    expandedRows: expandedRows,\n    rows: expandedRows,\n    expandedDepth: expandedDepth,\n    isAllRowsExpanded: isAllRowsExpanded,\n    toggleRowExpanded: toggleRowExpanded,\n    toggleAllRowsExpanded: toggleAllRowsExpanded,\n    getToggleAllRowsExpandedProps: getToggleAllRowsExpandedProps\n  });\n}\n\nfunction prepareRow(row, _ref3) {\n  var getHooks = _ref3.instance.getHooks,\n      instance = _ref3.instance;\n\n  row.toggleRowExpanded = function (set) {\n    return instance.toggleRowExpanded(row.id, set);\n  };\n\n  row.getToggleRowExpandedProps = makePropGetter(getHooks().getToggleRowExpandedProps, {\n    instance: instance,\n    row: row\n  });\n}\n\nfunction findExpandedDepth(expanded) {\n  var maxDepth = 0;\n  Object.keys(expanded).forEach(function (id) {\n    var splitId = id.split('.');\n    maxDepth = Math.max(maxDepth, splitId.length);\n  });\n  return maxDepth;\n}\n\nvar text = function text(rows, ids, filterValue) {\n  rows = rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id];\n      return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());\n    });\n  });\n  return rows;\n};\n\ntext.autoRemove = function (val) {\n  return !val;\n};\n\nvar exactText = function exactText(rows, ids, filterValue) {\n  return rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id];\n      return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;\n    });\n  });\n};\n\nexactText.autoRemove = function (val) {\n  return !val;\n};\n\nvar exactTextCase = function exactTextCase(rows, ids, filterValue) {\n  return rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id];\n      return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;\n    });\n  });\n};\n\nexactTextCase.autoRemove = function (val) {\n  return !val;\n};\n\nvar includes = function includes(rows, ids, filterValue) {\n  return rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id];\n      return filterValue.includes(rowValue);\n    });\n  });\n};\n\nincludes.autoRemove = function (val) {\n  return !val || !val.length;\n};\n\nvar includesAll = function includesAll(rows, ids, filterValue) {\n  return rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id];\n      return rowValue && rowValue.length && filterValue.every(function (val) {\n        return rowValue.includes(val);\n      });\n    });\n  });\n};\n\nincludesAll.autoRemove = function (val) {\n  return !val || !val.length;\n};\n\nvar exact = function exact(rows, ids, filterValue) {\n  return rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id];\n      return rowValue === filterValue;\n    });\n  });\n};\n\nexact.autoRemove = function (val) {\n  return typeof val === 'undefined';\n};\n\nvar equals = function equals(rows, ids, filterValue) {\n  return rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq\n\n      return rowValue == filterValue;\n    });\n  });\n};\n\nequals.autoRemove = function (val) {\n  return val == null;\n};\n\nvar between = function between(rows, ids, filterValue) {\n  var _ref = filterValue || [],\n      min = _ref[0],\n      max = _ref[1];\n\n  min = typeof min === 'number' ? min : -Infinity;\n  max = typeof max === 'number' ? max : Infinity;\n\n  if (min > max) {\n    var temp = min;\n    min = max;\n    max = temp;\n  }\n\n  return rows.filter(function (row) {\n    return ids.some(function (id) {\n      var rowValue = row.values[id];\n      return rowValue >= min && rowValue <= max;\n    });\n  });\n};\n\nbetween.autoRemove = function (val) {\n  return !val || typeof val[0] !== 'number' && typeof val[1] !== 'number';\n};\n\nvar filterTypes =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  text: text,\n  exactText: exactText,\n  exactTextCase: exactTextCase,\n  includes: includes,\n  includesAll: includesAll,\n  exact: exact,\n  equals: equals,\n  between: between\n});\nactions.resetFilters = 'resetFilters';\nactions.setFilter = 'setFilter';\nactions.setAllFilters = 'setAllFilters';\n\nvar useFilters = function useFilters(hooks) {\n  hooks.stateReducers.push(reducer$2);\n  hooks.useInstance.push(useInstance$2);\n};\n\nuseFilters.pluginName = 'useFilters';\n\nfunction reducer$2(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      filters: []\n    }, state);\n  }\n\n  if (action.type === actions.resetFilters) {\n    return _extends({}, state, {\n      filters: instance.initialState.filters || []\n    });\n  }\n\n  if (action.type === actions.setFilter) {\n    var columnId = action.columnId,\n        filterValue = action.filterValue;\n    var allColumns = instance.allColumns,\n        userFilterTypes = instance.filterTypes;\n    var column = allColumns.find(function (d) {\n      return d.id === columnId;\n    });\n\n    if (!column) {\n      throw new Error(\"React-Table: Could not find a column with id: \" + columnId);\n    }\n\n    var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n    var previousfilter = state.filters.find(function (d) {\n      return d.id === columnId;\n    });\n    var newFilter = functionalUpdate(filterValue, previousfilter && previousfilter.value); //\n\n    if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter, column)) {\n      return _extends({}, state, {\n        filters: state.filters.filter(function (d) {\n          return d.id !== columnId;\n        })\n      });\n    }\n\n    if (previousfilter) {\n      return _extends({}, state, {\n        filters: state.filters.map(function (d) {\n          if (d.id === columnId) {\n            return {\n              id: columnId,\n              value: newFilter\n            };\n          }\n\n          return d;\n        })\n      });\n    }\n\n    return _extends({}, state, {\n      filters: [].concat(state.filters, [{\n        id: columnId,\n        value: newFilter\n      }])\n    });\n  }\n\n  if (action.type === actions.setAllFilters) {\n    var filters = action.filters;\n    var _allColumns = instance.allColumns,\n        _userFilterTypes = instance.filterTypes;\n    return _extends({}, state, {\n      // Filter out undefined values\n      filters: functionalUpdate(filters, state.filters).filter(function (filter) {\n        var column = _allColumns.find(function (d) {\n          return d.id === filter.id;\n        });\n\n        var filterMethod = getFilterMethod(column.filter, _userFilterTypes || {}, filterTypes);\n\n        if (shouldAutoRemoveFilter(filterMethod.autoRemove, filter.value, column)) {\n          return false;\n        }\n\n        return true;\n      })\n    });\n  }\n}\n\nfunction useInstance$2(instance) {\n  var data = instance.data,\n      rows = instance.rows,\n      flatRows = instance.flatRows,\n      rowsById = instance.rowsById,\n      allColumns = instance.allColumns,\n      userFilterTypes = instance.filterTypes,\n      manualFilters = instance.manualFilters,\n      _instance$defaultCanF = instance.defaultCanFilter,\n      defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF,\n      disableFilters = instance.disableFilters,\n      filters = instance.state.filters,\n      dispatch = instance.dispatch,\n      _instance$autoResetFi = instance.autoResetFilters,\n      autoResetFilters = _instance$autoResetFi === void 0 ? true : _instance$autoResetFi;\n  var setFilter = React.useCallback(function (columnId, filterValue) {\n    dispatch({\n      type: actions.setFilter,\n      columnId: columnId,\n      filterValue: filterValue\n    });\n  }, [dispatch]);\n  var setAllFilters = React.useCallback(function (filters) {\n    dispatch({\n      type: actions.setAllFilters,\n      filters: filters\n    });\n  }, [dispatch]);\n  allColumns.forEach(function (column) {\n    var id = column.id,\n        accessor = column.accessor,\n        columnDefaultCanFilter = column.defaultCanFilter,\n        columnDisableFilters = column.disableFilters; // Determine if a column is filterable\n\n    column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value\n\n    column.setFilter = function (val) {\n      return setFilter(column.id, val);\n    }; // Provide the current filter value to the column for\n    // convenience\n\n\n    var found = filters.find(function (d) {\n      return d.id === id;\n    });\n    column.filterValue = found && found.value;\n  });\n\n  var _React$useMemo = React.useMemo(function () {\n    if (manualFilters || !filters.length) {\n      return [rows, flatRows, rowsById];\n    }\n\n    var filteredFlatRows = [];\n    var filteredRowsById = {}; // Filters top level and nested rows\n\n    var filterRows = function filterRows(rows, depth) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      var filteredRows = rows;\n      filteredRows = filters.reduce(function (filteredSoFar, _ref) {\n        var columnId = _ref.id,\n            filterValue = _ref.value; // Find the filters column\n\n        var column = allColumns.find(function (d) {\n          return d.id === columnId;\n        });\n\n        if (!column) {\n          return filteredSoFar;\n        }\n\n        if (depth === 0) {\n          column.preFilteredRows = filteredSoFar;\n        }\n\n        var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n        if (!filterMethod) {\n          console.warn(\"Could not find a valid 'column.filter' for column with the ID: \" + column.id + \".\");\n          return filteredSoFar;\n        } // Pass the rows, id, filterValue and column to the filterMethod\n        // to get the filtered rows back\n\n\n        column.filteredRows = filterMethod(filteredSoFar, [columnId], filterValue);\n        return column.filteredRows;\n      }, rows); // Apply the filter to any subRows\n      // We technically could do this recursively in the above loop,\n      // but that would severely hinder the API for the user, since they\n      // would be required to do that recursion in some scenarios\n\n      filteredRows = filteredRows.map(function (row) {\n        filteredFlatRows.push(row);\n        filteredRowsById[row.id] = row;\n\n        if (!row.subRows) {\n          return row;\n        }\n\n        return _extends({}, row, {\n          subRows: row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows\n        });\n      });\n      return filteredRows;\n    };\n\n    return [filterRows(rows), filteredFlatRows, filteredRowsById];\n  }, [manualFilters, filters, rows, flatRows, rowsById, allColumns, userFilterTypes]),\n      filteredRows = _React$useMemo[0],\n      filteredFlatRows = _React$useMemo[1],\n      filteredRowsById = _React$useMemo[2];\n\n  React.useMemo(function () {\n    // Now that each filtered column has it's partially filtered rows,\n    // lets assign the final filtered rows to all of the other columns\n    var nonFilteredColumns = allColumns.filter(function (column) {\n      return !filters.find(function (d) {\n        return d.id === column.id;\n      });\n    }); // This essentially enables faceted filter options to be built easily\n    // using every column's preFilteredRows value\n\n    nonFilteredColumns.forEach(function (column) {\n      column.preFilteredRows = filteredRows;\n      column.filteredRows = filteredRows;\n    });\n  }, [filteredRows, filters, allColumns]);\n  var getAutoResetFilters = useGetLatest(autoResetFilters);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetFilters()) {\n      dispatch({\n        type: actions.resetFilters\n      });\n    }\n  }, [dispatch, manualFilters ? null : data]);\n  Object.assign(instance, {\n    preFilteredRows: rows,\n    preFilteredFlatRows: flatRows,\n    preFilteredRowsById: rowsById,\n    filteredRows: filteredRows,\n    filteredFlatRows: filteredFlatRows,\n    filteredRowsById: filteredRowsById,\n    rows: filteredRows,\n    flatRows: filteredFlatRows,\n    rowsById: filteredRowsById,\n    setFilter: setFilter,\n    setAllFilters: setAllFilters\n  });\n}\n\nactions.resetGlobalFilter = 'resetGlobalFilter';\nactions.setGlobalFilter = 'setGlobalFilter';\n\nvar useGlobalFilter = function useGlobalFilter(hooks) {\n  hooks.stateReducers.push(reducer$3);\n  hooks.useInstance.push(useInstance$3);\n};\n\nuseGlobalFilter.pluginName = 'useGlobalFilter';\n\nfunction reducer$3(state, action, previousState, instance) {\n  if (action.type === actions.resetGlobalFilter) {\n    return _extends({}, state, {\n      globalFilter: instance.initialState.globalFilter || undefined\n    });\n  }\n\n  if (action.type === actions.setGlobalFilter) {\n    var filterValue = action.filterValue;\n    var userFilterTypes = instance.userFilterTypes;\n    var filterMethod = getFilterMethod(instance.globalFilter, userFilterTypes || {}, filterTypes);\n    var newFilter = functionalUpdate(filterValue, state.globalFilter); //\n\n    if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter)) {\n      var globalFilter = state.globalFilter,\n          stateWithoutGlobalFilter = _objectWithoutPropertiesLoose(state, [\"globalFilter\"]);\n\n      return stateWithoutGlobalFilter;\n    }\n\n    return _extends({}, state, {\n      globalFilter: newFilter\n    });\n  }\n}\n\nfunction useInstance$3(instance) {\n  var data = instance.data,\n      rows = instance.rows,\n      flatRows = instance.flatRows,\n      rowsById = instance.rowsById,\n      allColumns = instance.allColumns,\n      userFilterTypes = instance.filterTypes,\n      globalFilter = instance.globalFilter,\n      manualGlobalFilter = instance.manualGlobalFilter,\n      globalFilterValue = instance.state.globalFilter,\n      dispatch = instance.dispatch,\n      _instance$autoResetGl = instance.autoResetGlobalFilter,\n      autoResetGlobalFilter = _instance$autoResetGl === void 0 ? true : _instance$autoResetGl;\n  var setGlobalFilter = React.useCallback(function (filterValue) {\n    dispatch({\n      type: actions.setGlobalFilter,\n      filterValue: filterValue\n    });\n  }, [dispatch]); // TODO: Create a filter cache for incremental high speed multi-filtering\n  // This gets pretty complicated pretty fast, since you have to maintain a\n  // cache for each row group (top-level rows, and each row's recursive subrows)\n  // This would make multi-filtering a lot faster though. Too far?\n\n  var _React$useMemo = React.useMemo(function () {\n    if (manualGlobalFilter || typeof globalFilterValue === 'undefined') {\n      return [rows, flatRows, rowsById];\n    }\n\n    var filteredFlatRows = [];\n    var filteredRowsById = {};\n    var filterMethod = getFilterMethod(globalFilter, userFilterTypes || {}, filterTypes);\n\n    if (!filterMethod) {\n      console.warn(\"Could not find a valid 'globalFilter' option.\");\n      return rows;\n    } // Filters top level and nested rows\n\n\n    var filterRows = function filterRows(filteredRows) {\n      return filterMethod(filteredRows, allColumns.map(function (d) {\n        return d.id;\n      }), globalFilterValue).map(function (row) {\n        filteredFlatRows.push(row);\n        filteredRowsById[row.id] = row;\n        return _extends({}, row, {\n          subRows: row.subRows && row.subRows.length ? filterRows(row.subRows) : row.subRows\n        });\n      });\n    };\n\n    return [filterRows(rows), filteredFlatRows, filteredRowsById];\n  }, [manualGlobalFilter, globalFilterValue, globalFilter, userFilterTypes, rows, flatRows, rowsById, allColumns]),\n      globalFilteredRows = _React$useMemo[0],\n      globalFilteredFlatRows = _React$useMemo[1],\n      globalFilteredRowsById = _React$useMemo[2];\n\n  var getAutoResetGlobalFilter = useGetLatest(autoResetGlobalFilter);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetGlobalFilter()) {\n      dispatch({\n        type: actions.resetGlobalFilter\n      });\n    }\n  }, [dispatch, manualGlobalFilter ? null : data]);\n  Object.assign(instance, {\n    preGlobalFilteredRows: rows,\n    preGlobalFilteredFlatRows: flatRows,\n    preGlobalFilteredRowsById: rowsById,\n    globalFilteredRows: globalFilteredRows,\n    globalFilteredFlatRows: globalFilteredFlatRows,\n    globalFilteredRowsById: globalFilteredRowsById,\n    rows: globalFilteredRows,\n    flatRows: globalFilteredFlatRows,\n    rowsById: globalFilteredRowsById,\n    setGlobalFilter: setGlobalFilter\n  });\n}\n\nfunction sum(values, aggregatedValues) {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return aggregatedValues.reduce(function (sum, next) {\n    return sum + (typeof next === 'number' ? next : 0);\n  }, 0);\n}\n\nfunction min(values) {\n  var min = 0;\n  values.forEach(function (value) {\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n    }\n  });\n  return min;\n}\n\nfunction max(values) {\n  var max = 0;\n  values.forEach(function (value) {\n    if (typeof value === 'number') {\n      max = Math.max(max, value);\n    }\n  });\n  return max;\n}\n\nfunction minMax(values) {\n  var min = 0;\n  var max = 0;\n  values.forEach(function (value) {\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n    }\n  });\n  return min + \"..\" + max;\n}\n\nfunction average(values) {\n  return sum(null, values) / values.length;\n}\n\nfunction median(values) {\n  if (!values.length) {\n    return null;\n  }\n\n  var min = 0;\n  var max = 0;\n  values.forEach(function (value) {\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n    }\n  });\n  return (min + max) / 2;\n}\n\nfunction unique(values) {\n  return [].concat(new Set(values).values());\n}\n\nfunction uniqueCount(values) {\n  return new Set(values).size;\n}\n\nfunction count(values) {\n  return values.length;\n}\n\nvar aggregations =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  sum: sum,\n  min: min,\n  max: max,\n  minMax: minMax,\n  average: average,\n  median: median,\n  unique: unique,\n  uniqueCount: uniqueCount,\n  count: count\n});\nvar emptyArray = [];\nvar emptyObject = {}; // Actions\n\nactions.resetGroupBy = 'resetGroupBy';\nactions.toggleGroupBy = 'toggleGroupBy';\n\nvar useGroupBy = function useGroupBy(hooks) {\n  hooks.getGroupByToggleProps = [defaultGetGroupByToggleProps];\n  hooks.stateReducers.push(reducer$4);\n  hooks.visibleColumnsDeps.push(function (deps, _ref) {\n    var instance = _ref.instance;\n    return [].concat(deps, [instance.state.groupBy]);\n  });\n  hooks.visibleColumns.push(visibleColumns);\n  hooks.useInstance.push(useInstance$4);\n  hooks.prepareRow.push(prepareRow$1);\n};\n\nuseGroupBy.pluginName = 'useGroupBy';\n\nvar defaultGetGroupByToggleProps = function defaultGetGroupByToggleProps(props, _ref2) {\n  var header = _ref2.header;\n  return [props, {\n    onClick: header.canGroupBy ? function (e) {\n      e.persist();\n      header.toggleGroupBy();\n    } : undefined,\n    style: {\n      cursor: header.canGroupBy ? 'pointer' : undefined\n    },\n    title: 'Toggle GroupBy'\n  }];\n}; // Reducer\n\n\nfunction reducer$4(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      groupBy: []\n    }, state);\n  }\n\n  if (action.type === actions.resetGroupBy) {\n    return _extends({}, state, {\n      groupBy: instance.initialState.groupBy || []\n    });\n  }\n\n  if (action.type === actions.toggleGroupBy) {\n    var columnId = action.columnId,\n        setGroupBy = action.value;\n    var resolvedGroupBy = typeof setGroupBy !== 'undefined' ? setGroupBy : !state.groupBy.includes(columnId);\n\n    if (resolvedGroupBy) {\n      return _extends({}, state, {\n        groupBy: [].concat(state.groupBy, [columnId])\n      });\n    }\n\n    return _extends({}, state, {\n      groupBy: state.groupBy.filter(function (d) {\n        return d !== columnId;\n      })\n    });\n  }\n}\n\nfunction visibleColumns(columns, _ref3) {\n  var groupBy = _ref3.instance.state.groupBy; // Sort grouped columns to the start of the column list\n  // before the headers are built\n\n  var groupByColumns = groupBy.map(function (g) {\n    return columns.find(function (col) {\n      return col.id === g;\n    });\n  }).filter(Boolean);\n  var nonGroupByColumns = columns.filter(function (col) {\n    return !groupBy.includes(col.id);\n  });\n  columns = [].concat(groupByColumns, nonGroupByColumns);\n  columns.forEach(function (column) {\n    column.isGrouped = groupBy.includes(column.id);\n    column.groupedIndex = groupBy.indexOf(column.id);\n  });\n  return columns;\n}\n\nvar defaultUserAggregations = {};\n\nfunction useInstance$4(instance) {\n  var data = instance.data,\n      rows = instance.rows,\n      flatRows = instance.flatRows,\n      rowsById = instance.rowsById,\n      allColumns = instance.allColumns,\n      flatHeaders = instance.flatHeaders,\n      _instance$groupByFn = instance.groupByFn,\n      groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn,\n      manualGroupBy = instance.manualGroupBy,\n      _instance$aggregation = instance.aggregations,\n      userAggregations = _instance$aggregation === void 0 ? defaultUserAggregations : _instance$aggregation,\n      plugins = instance.plugins,\n      groupBy = instance.state.groupBy,\n      dispatch = instance.dispatch,\n      _instance$autoResetGr = instance.autoResetGroupBy,\n      autoResetGroupBy = _instance$autoResetGr === void 0 ? true : _instance$autoResetGr,\n      disableGroupBy = instance.disableGroupBy,\n      defaultCanGroupBy = instance.defaultCanGroupBy,\n      getHooks = instance.getHooks;\n  ensurePluginOrder(plugins, ['useFilters'], 'useGroupBy');\n  var getInstance = useGetLatest(instance);\n  allColumns.forEach(function (column) {\n    var accessor = column.accessor,\n        defaultColumnGroupBy = column.defaultGroupBy,\n        columnDisableGroupBy = column.disableGroupBy;\n    column.canGroupBy = accessor ? getFirstDefined(column.canGroupBy, columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(column.canGroupBy, defaultColumnGroupBy, defaultCanGroupBy, false);\n\n    if (column.canGroupBy) {\n      column.toggleGroupBy = function () {\n        return instance.toggleGroupBy(column.id);\n      };\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell;\n  });\n  var toggleGroupBy = React.useCallback(function (columnId, value) {\n    dispatch({\n      type: actions.toggleGroupBy,\n      columnId: columnId,\n      value: value\n    });\n  }, [dispatch]);\n  flatHeaders.forEach(function (header) {\n    header.getGroupByToggleProps = makePropGetter(getHooks().getGroupByToggleProps, {\n      instance: getInstance(),\n      header: header\n    });\n  });\n\n  var _React$useMemo = React.useMemo(function () {\n    if (manualGroupBy || !groupBy.length) {\n      return [rows, flatRows, rowsById, emptyArray, emptyObject, flatRows, rowsById];\n    } // Ensure that the list of filtered columns exist\n\n\n    var existingGroupBy = groupBy.filter(function (g) {\n      return allColumns.find(function (col) {\n        return col.id === g;\n      });\n    }); // Find the columns that can or are aggregating\n    // Uses each column to aggregate rows into a single value\n\n    var aggregateRowsToValues = function aggregateRowsToValues(leafRows, groupedRows, depth) {\n      var values = {};\n      allColumns.forEach(function (column) {\n        // Don't aggregate columns that are in the groupBy\n        if (existingGroupBy.includes(column.id)) {\n          values[column.id] = groupedRows[0] ? groupedRows[0].values[column.id] : null;\n          return;\n        } // Get the columnValues to aggregate\n\n\n        var groupedValues = groupedRows.map(function (row) {\n          return row.values[column.id];\n        }); // Get the columnValues to aggregate\n\n        var leafValues = leafRows.map(function (row) {\n          var columnValue = row.values[column.id];\n\n          if (!depth && column.aggregatedValue) {\n            var aggregateValueFn = typeof column.aggregateValue === 'function' ? column.aggregateValue : userAggregations[column.aggregateValue] || aggregations[column.aggregateValue];\n\n            if (!aggregateValueFn) {\n              console.info({\n                column: column\n              });\n              throw new Error(\"React Table: Invalid column.aggregateValue option for column listed above\");\n            }\n\n            columnValue = aggregateValueFn(columnValue, row, column);\n          }\n\n          return columnValue;\n        }); // Aggregate the values\n\n        var aggregateFn = typeof column.aggregate === 'function' ? column.aggregate : userAggregations[column.aggregate] || aggregations[column.aggregate];\n\n        if (aggregateFn) {\n          values[column.id] = aggregateFn(leafValues, groupedValues);\n        } else if (column.aggregate) {\n          console.info({\n            column: column\n          });\n          throw new Error(\"React Table: Invalid column.aggregate option for column listed above\");\n        } else {\n          values[column.id] = null;\n        }\n      });\n      return values;\n    };\n\n    var groupedFlatRows = [];\n    var groupedRowsById = {};\n    var onlyGroupedFlatRows = [];\n    var onlyGroupedRowsById = {};\n    var nonGroupedFlatRows = [];\n    var nonGroupedRowsById = {}; // Recursively group the data\n\n    var groupUpRecursively = function groupUpRecursively(rows, depth, parentId) {\n      if (depth === void 0) {\n        depth = 0;\n      } // This is the last level, just return the rows\n\n\n      if (depth === existingGroupBy.length) {\n        return rows;\n      }\n\n      var columnId = existingGroupBy[depth]; // Group the rows together for this level\n\n      var rowGroupsMap = groupByFn(rows, columnId); // Peform aggregations for each group\n\n      var aggregatedGroupedRows = Object.entries(rowGroupsMap).map(function (_ref4, index) {\n        var groupByVal = _ref4[0],\n            groupedRows = _ref4[1];\n        var id = columnId + \":\" + groupByVal;\n        id = parentId ? parentId + \">\" + id : id; // First, Recurse to group sub rows before aggregation\n\n        var subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n\n        var leafRows = depth ? flattenBy(groupedRows, 'leafRows') : groupedRows;\n        var values = aggregateRowsToValues(leafRows, groupedRows, depth);\n        var row = {\n          id: id,\n          isGrouped: true,\n          groupByID: columnId,\n          groupByVal: groupByVal,\n          values: values,\n          subRows: subRows,\n          leafRows: leafRows,\n          depth: depth,\n          index: index\n        };\n        subRows.forEach(function (subRow) {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow;\n\n          if (subRow.isGrouped) {\n            onlyGroupedFlatRows.push(subRow);\n            onlyGroupedRowsById[subRow.id] = subRow;\n          } else {\n            nonGroupedFlatRows.push(subRow);\n            nonGroupedRowsById[subRow.id] = subRow;\n          }\n        });\n        return row;\n      });\n      return aggregatedGroupedRows;\n    };\n\n    var groupedRows = groupUpRecursively(rows);\n    groupedRows.forEach(function (subRow) {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow;\n\n      if (subRow.isGrouped) {\n        onlyGroupedFlatRows.push(subRow);\n        onlyGroupedRowsById[subRow.id] = subRow;\n      } else {\n        nonGroupedFlatRows.push(subRow);\n        nonGroupedRowsById[subRow.id] = subRow;\n      }\n    }); // Assign the new data\n\n    return [groupedRows, groupedFlatRows, groupedRowsById, onlyGroupedFlatRows, onlyGroupedRowsById, nonGroupedFlatRows, nonGroupedRowsById];\n  }, [manualGroupBy, groupBy, rows, flatRows, rowsById, allColumns, userAggregations, groupByFn]),\n      groupedRows = _React$useMemo[0],\n      groupedFlatRows = _React$useMemo[1],\n      groupedRowsById = _React$useMemo[2],\n      onlyGroupedFlatRows = _React$useMemo[3],\n      onlyGroupedRowsById = _React$useMemo[4],\n      nonGroupedFlatRows = _React$useMemo[5],\n      nonGroupedRowsById = _React$useMemo[6];\n\n  var getAutoResetGroupBy = useGetLatest(autoResetGroupBy);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetGroupBy()) {\n      dispatch({\n        type: actions.resetGroupBy\n      });\n    }\n  }, [dispatch, manualGroupBy ? null : data]);\n  Object.assign(instance, {\n    preGroupedRows: rows,\n    preGroupedFlatRow: flatRows,\n    preGroupedRowsById: rowsById,\n    groupedRows: groupedRows,\n    groupedFlatRows: groupedFlatRows,\n    groupedRowsById: groupedRowsById,\n    onlyGroupedFlatRows: onlyGroupedFlatRows,\n    onlyGroupedRowsById: onlyGroupedRowsById,\n    nonGroupedFlatRows: nonGroupedFlatRows,\n    nonGroupedRowsById: nonGroupedRowsById,\n    rows: groupedRows,\n    flatRows: groupedFlatRows,\n    rowsById: groupedRowsById,\n    toggleGroupBy: toggleGroupBy\n  });\n}\n\nfunction prepareRow$1(row) {\n  row.allCells.forEach(function (cell) {\n    // Grouped cells are in the groupBy and the pivot cell for the row\n    cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Placeholder cells are any columns in the groupBy that are not grouped\n\n    cell.isPlaceholder = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows\n\n    cell.isAggregated = !cell.isGrouped && !cell.isPlaceholder && row.canExpand;\n  });\n}\n\nvar reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\n\nvar alphanumeric = function alphanumeric(rowA, rowB, columnId) {\n  var a = getRowValueByColumnID(rowA, columnId);\n  var b = getRowValueByColumnID(rowB, columnId); // Force to strings (or \"\" for unsupported types)\n\n  a = toString(a);\n  b = toString(b); // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n\n  a = a.split(reSplitAlphaNumeric).filter(Boolean);\n  b = b.split(reSplitAlphaNumeric).filter(Boolean); // While\n\n  while (a.length && b.length) {\n    var aa = a.shift();\n    var bb = b.shift();\n    var an = parseInt(aa, 10);\n    var bn = parseInt(bb, 10);\n    var combo = [an, bn].sort(); // Both are string\n\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n\n      if (bb > aa) {\n        return -1;\n      }\n\n      continue;\n    } // One is a string, one is a number\n\n\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    } // Both are numbers\n\n\n    if (an > bn) {\n      return 1;\n    }\n\n    if (bn > an) {\n      return -1;\n    }\n  }\n\n  return a.length - b.length;\n};\n\nfunction datetime(rowA, rowB, columnId) {\n  var a = getRowValueByColumnID(rowA, columnId);\n  var b = getRowValueByColumnID(rowB, columnId);\n  a = a.getTime();\n  b = b.getTime();\n  return compareBasic(a, b);\n}\n\nfunction basic(rowA, rowB, columnId) {\n  var a = getRowValueByColumnID(rowA, columnId);\n  var b = getRowValueByColumnID(rowB, columnId);\n  return compareBasic(a, b);\n} // Utils\n\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction getRowValueByColumnID(row, columnId) {\n  return row.values[columnId];\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n\n    return String(a);\n  }\n\n  if (typeof a === 'string') {\n    return a;\n  }\n\n  return '';\n}\n\nvar sortTypes =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  alphanumeric: alphanumeric,\n  datetime: datetime,\n  basic: basic\n});\nactions.resetSortBy = 'resetSortBy';\nactions.toggleSortBy = 'toggleSortBy';\nactions.clearSortBy = 'clearSortBy';\ndefaultColumn.sortType = 'alphanumeric';\ndefaultColumn.sortDescFirst = false;\n\nvar useSortBy = function useSortBy(hooks) {\n  hooks.getSortByToggleProps = [defaultGetSortByToggleProps];\n  hooks.stateReducers.push(reducer$5);\n  hooks.useInstance.push(useInstance$5);\n};\n\nuseSortBy.pluginName = 'useSortBy';\n\nvar defaultGetSortByToggleProps = function defaultGetSortByToggleProps(props, _ref) {\n  var instance = _ref.instance,\n      column = _ref.column;\n  var _instance$isMultiSort = instance.isMultiSortEvent,\n      isMultiSortEvent = _instance$isMultiSort === void 0 ? function (e) {\n    return e.shiftKey;\n  } : _instance$isMultiSort;\n  return [props, {\n    onClick: column.canSort ? function (e) {\n      e.persist();\n      column.toggleSortBy(undefined, !instance.disableMultiSort && isMultiSortEvent(e));\n    } : undefined,\n    style: {\n      cursor: column.canSort ? 'pointer' : undefined\n    },\n    title: column.canSort ? 'Toggle SortBy' : undefined\n  }];\n}; // Reducer\n\n\nfunction reducer$5(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      sortBy: []\n    }, state);\n  }\n\n  if (action.type === actions.resetSortBy) {\n    return _extends({}, state, {\n      sortBy: instance.initialState.sortBy || []\n    });\n  }\n\n  if (action.type === actions.clearSortBy) {\n    var sortBy = state.sortBy;\n    var newSortBy = sortBy.filter(function (d) {\n      return d.id !== action.columnId;\n    });\n    return _extends({}, state, {\n      sortBy: newSortBy\n    });\n  }\n\n  if (action.type === actions.toggleSortBy) {\n    var columnId = action.columnId,\n        desc = action.desc,\n        multi = action.multi;\n    var allColumns = instance.allColumns,\n        disableMultiSort = instance.disableMultiSort,\n        disableSortRemove = instance.disableSortRemove,\n        disableMultiRemove = instance.disableMultiRemove,\n        _instance$maxMultiSor = instance.maxMultiSortColCount,\n        maxMultiSortColCount = _instance$maxMultiSor === void 0 ? Number.MAX_SAFE_INTEGER : _instance$maxMultiSor;\n    var _sortBy = state.sortBy; // Find the column for this columnId\n\n    var column = allColumns.find(function (d) {\n      return d.id === columnId;\n    });\n    var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column\n\n    var existingSortBy = _sortBy.find(function (d) {\n      return d.id === columnId;\n    });\n\n    var existingIndex = _sortBy.findIndex(function (d) {\n      return d.id === columnId;\n    });\n\n    var hasDescDefined = typeof desc !== 'undefined' && desc !== null;\n    var _newSortBy = []; // What should we do with this sort action?\n\n    var sortAction;\n\n    if (!disableMultiSort && multi) {\n      if (existingSortBy) {\n        sortAction = 'toggle';\n      } else {\n        sortAction = 'add';\n      }\n    } else {\n      // Normal mode\n      if (existingIndex !== _sortBy.length - 1) {\n        sortAction = 'replace';\n      } else if (existingSortBy) {\n        sortAction = 'toggle';\n      } else {\n        sortAction = 'replace';\n      }\n    } // Handle toggle states that will remove the sortBy\n\n\n    if (sortAction === 'toggle' && // Must be toggling\n    !disableSortRemove && // If disableSortRemove, disable in general\n    !hasDescDefined && ( // Must not be setting desc\n    multi ? !disableMultiRemove : true) && ( // If multi, don't allow if disableMultiRemove\n    existingSortBy && // Finally, detect if it should indeed be removed\n    existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {\n      sortAction = 'remove';\n    }\n\n    if (sortAction === 'replace') {\n      _newSortBy = [{\n        id: columnId,\n        desc: hasDescDefined ? desc : sortDescFirst\n      }];\n    } else if (sortAction === 'add') {\n      _newSortBy = [].concat(_sortBy, [{\n        id: columnId,\n        desc: hasDescDefined ? desc : sortDescFirst\n      }]); // Take latest n columns\n\n      _newSortBy.splice(0, _newSortBy.length - maxMultiSortColCount);\n    } else if (sortAction === 'toggle') {\n      // This flips (or sets) the\n      _newSortBy = _sortBy.map(function (d) {\n        if (d.id === columnId) {\n          return _extends({}, d, {\n            desc: hasDescDefined ? desc : !existingSortBy.desc\n          });\n        }\n\n        return d;\n      });\n    } else if (sortAction === 'remove') {\n      _newSortBy = _sortBy.filter(function (d) {\n        return d.id !== columnId;\n      });\n    }\n\n    return _extends({}, state, {\n      sortBy: _newSortBy\n    });\n  }\n}\n\nfunction useInstance$5(instance) {\n  var data = instance.data,\n      rows = instance.rows,\n      flatRows = instance.flatRows,\n      allColumns = instance.allColumns,\n      _instance$orderByFn = instance.orderByFn,\n      orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn,\n      userSortTypes = instance.sortTypes,\n      manualSortBy = instance.manualSortBy,\n      defaultCanSort = instance.defaultCanSort,\n      disableSortBy = instance.disableSortBy,\n      flatHeaders = instance.flatHeaders,\n      sortBy = instance.state.sortBy,\n      dispatch = instance.dispatch,\n      plugins = instance.plugins,\n      getHooks = instance.getHooks,\n      _instance$autoResetSo = instance.autoResetSortBy,\n      autoResetSortBy = _instance$autoResetSo === void 0 ? true : _instance$autoResetSo;\n  ensurePluginOrder(plugins, ['useFilters', 'useGlobalFilter', 'useGroupBy', 'usePivotColumns'], 'useSortBy'); // Updates sorting based on a columnId, desc flag and multi flag\n\n  var toggleSortBy = React.useCallback(function (columnId, desc, multi) {\n    dispatch({\n      type: actions.toggleSortBy,\n      columnId: columnId,\n      desc: desc,\n      multi: multi\n    });\n  }, [dispatch]); // use reference to avoid memory leak in #1608\n\n  var getInstance = useGetLatest(instance); // Add the getSortByToggleProps method to columns and headers\n\n  flatHeaders.forEach(function (column) {\n    var accessor = column.accessor,\n        defaultColumnCanSort = column.canSort,\n        columnDisableSortBy = column.disableSortBy,\n        id = column.id;\n    var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);\n    column.canSort = canSort;\n\n    if (column.canSort) {\n      column.toggleSortBy = function (desc, multi) {\n        return toggleSortBy(column.id, desc, multi);\n      };\n\n      column.clearSortBy = function () {\n        dispatch({\n          type: actions.clearSortBy,\n          columnId: column.id\n        });\n      };\n    }\n\n    column.getSortByToggleProps = makePropGetter(getHooks().getSortByToggleProps, {\n      instance: getInstance(),\n      column: column\n    });\n    var columnSort = sortBy.find(function (d) {\n      return d.id === id;\n    });\n    column.isSorted = !!columnSort;\n    column.sortedIndex = sortBy.findIndex(function (d) {\n      return d.id === id;\n    });\n    column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;\n  });\n\n  var _React$useMemo = React.useMemo(function () {\n    if (manualSortBy || !sortBy.length) {\n      return [rows, flatRows];\n    }\n\n    var sortedFlatRows = []; // Filter out sortBys that correspond to non existing columns\n\n    var availableSortBy = sortBy.filter(function (sort) {\n      return allColumns.find(function (col) {\n        return col.id === sort.id;\n      });\n    });\n\n    var sortData = function sortData(rows) {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      var sortedData = orderByFn(rows, availableSortBy.map(function (sort) {\n        // Support custom sorting methods for each column\n        var column = allColumns.find(function (d) {\n          return d.id === sort.id;\n        });\n\n        if (!column) {\n          throw new Error(\"React-Table: Could not find a column with id: \" + sort.id + \" while sorting\");\n        }\n\n        var sortType = column.sortType; // Look up sortBy functions in this order:\n        // column function\n        // column string lookup on user sortType\n        // column string lookup on built-in sortType\n        // default function\n        // default string lookup on user sortType\n        // default string lookup on built-in sortType\n\n        var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];\n\n        if (!sortMethod) {\n          throw new Error(\"React-Table: Could not find a valid sortType of '\" + sortType + \"' for column '\" + sort.id + \"'.\");\n        } // Return the correct sortFn.\n        // This function should always return in ascending order\n\n\n        return function (a, b) {\n          return sortMethod(a, b, sort.id, sort.desc);\n        };\n      }), // Map the directions\n      availableSortBy.map(function (sort) {\n        // Detect and use the sortInverted option\n        var column = allColumns.find(function (d) {\n          return d.id === sort.id;\n        });\n\n        if (column && column.sortInverted) {\n          return sort.desc;\n        }\n\n        return !sort.desc;\n      })); // If there are sub-rows, sort them\n\n      sortedData.forEach(function (row) {\n        sortedFlatRows.push(row);\n\n        if (!row.subRows || row.subRows.length <= 1) {\n          return;\n        }\n\n        row.subRows = sortData(row.subRows);\n      });\n      return sortedData;\n    };\n\n    return [sortData(rows), sortedFlatRows];\n  }, [manualSortBy, sortBy, rows, flatRows, allColumns, orderByFn, userSortTypes]),\n      sortedRows = _React$useMemo[0],\n      sortedFlatRows = _React$useMemo[1];\n\n  var getAutoResetSortBy = useGetLatest(autoResetSortBy);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetSortBy()) {\n      dispatch({\n        type: actions.resetSortBy\n      });\n    }\n  }, [manualSortBy ? null : data]);\n  Object.assign(instance, {\n    preSortedRows: rows,\n    preSortedFlatRows: flatRows,\n    sortedRows: sortedRows,\n    sortedFlatRows: sortedFlatRows,\n    rows: sortedRows,\n    flatRows: sortedFlatRows,\n    toggleSortBy: toggleSortBy\n  });\n}\n\nvar pluginName = 'usePagination'; // Actions\n\nactions.resetPage = 'resetPage';\nactions.gotoPage = 'gotoPage';\nactions.setPageSize = 'setPageSize';\n\nvar usePagination = function usePagination(hooks) {\n  hooks.stateReducers.push(reducer$6);\n  hooks.useInstance.push(useInstance$6);\n};\n\nusePagination.pluginName = pluginName;\n\nfunction reducer$6(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      pageSize: 10,\n      pageIndex: 0\n    }, state);\n  }\n\n  if (action.type === actions.resetPage) {\n    return _extends({}, state, {\n      pageIndex: instance.initialState.pageIndex || 0\n    });\n  }\n\n  if (action.type === actions.gotoPage) {\n    var pageCount = instance.pageCount;\n    var newPageIndex = functionalUpdate(action.pageIndex, state.pageIndex);\n\n    if (newPageIndex < 0 || newPageIndex > pageCount - 1) {\n      return state;\n    }\n\n    return _extends({}, state, {\n      pageIndex: newPageIndex\n    });\n  }\n\n  if (action.type === actions.setPageSize) {\n    var pageSize = action.pageSize;\n    var topRowIndex = state.pageSize * state.pageIndex;\n    var pageIndex = Math.floor(topRowIndex / pageSize);\n    return _extends({}, state, {\n      pageIndex: pageIndex,\n      pageSize: pageSize\n    });\n  }\n}\n\nfunction useInstance$6(instance) {\n  var rows = instance.rows,\n      _instance$autoResetPa = instance.autoResetPage,\n      autoResetPage = _instance$autoResetPa === void 0 ? true : _instance$autoResetPa,\n      _instance$manualExpan = instance.manualExpandedKey,\n      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n      plugins = instance.plugins,\n      userPageCount = instance.pageCount,\n      _instance$paginateExp = instance.paginateExpandedRows,\n      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n      _instance$expandSubRo = instance.expandSubRows,\n      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n      _instance$state = instance.state,\n      pageSize = _instance$state.pageSize,\n      pageIndex = _instance$state.pageIndex,\n      expanded = _instance$state.expanded,\n      globalFilter = _instance$state.globalFilter,\n      filters = _instance$state.filters,\n      groupBy = _instance$state.groupBy,\n      sortBy = _instance$state.sortBy,\n      dispatch = instance.dispatch,\n      data = instance.data,\n      manualPagination = instance.manualPagination,\n      manualGlobalFilter = instance.manualGlobalFilter,\n      manualFilters = instance.manualFilters,\n      manualGroupBy = instance.manualGroupBy,\n      manualSortBy = instance.manualSortBy;\n  ensurePluginOrder(plugins, ['useGlobalFilter', 'useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'], 'usePagination');\n  var getAutoResetPage = useGetLatest(autoResetPage);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetPage()) {\n      dispatch({\n        type: actions.resetPage\n      });\n    }\n  }, [dispatch, manualPagination ? null : data, manualGlobalFilter ? null : globalFilter, manualFilters ? null : filters, manualGroupBy ? null : groupBy, manualSortBy ? null : sortBy]);\n  var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);\n  var pageOptions = React.useMemo(function () {\n    return pageCount > 0 ? [].concat(new Array(pageCount)).map(function (d, i) {\n      return i;\n    }) : [];\n  }, [pageCount]);\n  var page = React.useMemo(function () {\n    var page;\n\n    if (manualPagination) {\n      page = rows;\n    } else {\n      var pageStart = pageSize * pageIndex;\n      var pageEnd = pageStart + pageSize;\n      page = rows.slice(pageStart, pageEnd);\n    }\n\n    if (paginateExpandedRows) {\n      return page;\n    }\n\n    return expandRows(page, {\n      manualExpandedKey: manualExpandedKey,\n      expanded: expanded,\n      expandSubRows: expandSubRows\n    });\n  }, [expandSubRows, expanded, manualExpandedKey, manualPagination, pageIndex, pageSize, paginateExpandedRows, rows]);\n  var canPreviousPage = pageIndex > 0;\n  var canNextPage = pageCount === -1 || pageIndex < pageCount - 1;\n  var gotoPage = React.useCallback(function (pageIndex) {\n    dispatch({\n      type: actions.gotoPage,\n      pageIndex: pageIndex\n    });\n  }, [dispatch]);\n  var previousPage = React.useCallback(function () {\n    return gotoPage(function (old) {\n      return old - 1;\n    });\n  }, [gotoPage]);\n  var nextPage = React.useCallback(function () {\n    return gotoPage(function (old) {\n      return old + 1;\n    });\n  }, [gotoPage]);\n  var setPageSize = React.useCallback(function (pageSize) {\n    dispatch({\n      type: actions.setPageSize,\n      pageSize: pageSize\n    });\n  }, [dispatch]);\n  Object.assign(instance, {\n    pageOptions: pageOptions,\n    pageCount: pageCount,\n    page: page,\n    canPreviousPage: canPreviousPage,\n    canNextPage: canNextPage,\n    gotoPage: gotoPage,\n    previousPage: previousPage,\n    nextPage: nextPage,\n    setPageSize: setPageSize\n  });\n}\n\nactions.resetPivot = 'resetPivot';\nactions.togglePivot = 'togglePivot';\n\nvar _UNSTABLE_usePivotColumns = function _UNSTABLE_usePivotColumns(hooks) {\n  hooks.getPivotToggleProps = [defaultGetPivotToggleProps];\n  hooks.stateReducers.push(reducer$7);\n  hooks.useInstanceAfterData.push(useInstanceAfterData);\n  hooks.allColumns.push(allColumns);\n  hooks.accessValue.push(accessValue);\n  hooks.materializedColumns.push(materializedColumns);\n  hooks.materializedColumnsDeps.push(materializedColumnsDeps);\n  hooks.visibleColumns.push(visibleColumns$1);\n  hooks.visibleColumnsDeps.push(visibleColumnsDeps);\n  hooks.useInstance.push(useInstance$7);\n  hooks.prepareRow.push(prepareRow$2);\n};\n\n_UNSTABLE_usePivotColumns.pluginName = 'usePivotColumns';\nvar defaultPivotColumns = [];\n\nvar defaultGetPivotToggleProps = function defaultGetPivotToggleProps(props, _ref) {\n  var header = _ref.header;\n  return [props, {\n    onClick: header.canPivot ? function (e) {\n      e.persist();\n      header.togglePivot();\n    } : undefined,\n    style: {\n      cursor: header.canPivot ? 'pointer' : undefined\n    },\n    title: 'Toggle Pivot'\n  }];\n}; // Reducer\n\n\nfunction reducer$7(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      pivotColumns: defaultPivotColumns\n    }, state);\n  }\n\n  if (action.type === actions.resetPivot) {\n    return _extends({}, state, {\n      pivotColumns: instance.initialState.pivotColumns || defaultPivotColumns\n    });\n  }\n\n  if (action.type === actions.togglePivot) {\n    var columnId = action.columnId,\n        setPivot = action.value;\n    var resolvedPivot = typeof setPivot !== 'undefined' ? setPivot : !state.pivotColumns.includes(columnId);\n\n    if (resolvedPivot) {\n      return _extends({}, state, {\n        pivotColumns: [].concat(state.pivotColumns, [columnId])\n      });\n    }\n\n    return _extends({}, state, {\n      pivotColumns: state.pivotColumns.filter(function (d) {\n        return d !== columnId;\n      })\n    });\n  }\n}\n\nfunction useInstanceAfterData(instance) {\n  instance.allColumns.forEach(function (column) {\n    column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n  });\n}\n\nfunction allColumns(columns, _ref2) {\n  var instance = _ref2.instance;\n  columns.forEach(function (column) {\n    column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n    column.uniqueValues = new Set();\n  });\n  return columns;\n}\n\nfunction accessValue(value, _ref3) {\n  var column = _ref3.column;\n\n  if (column.uniqueValues && typeof value !== 'undefined') {\n    column.uniqueValues.add(value);\n  }\n\n  return value;\n}\n\nfunction materializedColumns(materialized, _ref4) {\n  var instance = _ref4.instance;\n  var allColumns = instance.allColumns,\n      state = instance.state;\n\n  if (!state.pivotColumns.length || !state.groupBy || !state.groupBy.length) {\n    return materialized;\n  }\n\n  var pivotColumns = state.pivotColumns.map(function (id) {\n    return allColumns.find(function (d) {\n      return d.id === id;\n    });\n  }).filter(Boolean);\n  var sourceColumns = allColumns.filter(function (d) {\n    return !d.isPivotSource && !state.groupBy.includes(d.id) && !state.pivotColumns.includes(d.id);\n  });\n\n  var buildPivotColumns = function buildPivotColumns(depth, parent, pivotFilters) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    if (pivotFilters === void 0) {\n      pivotFilters = [];\n    }\n\n    var pivotColumn = pivotColumns[depth];\n\n    if (!pivotColumn) {\n      return sourceColumns.map(function (sourceColumn) {\n        // TODO: We could offer support here for renesting pivoted\n        // columns inside copies of their header groups. For now,\n        // that seems like it would be (1) overkill on nesting, considering\n        // you already get nesting for every pivot level and (2)\n        // really hard. :)\n        return _extends({}, sourceColumn, {\n          canPivot: false,\n          isPivoted: true,\n          parent: parent,\n          depth: depth,\n          id: \"\" + (parent ? parent.id + \".\" + sourceColumn.id : sourceColumn.id),\n          accessor: function accessor(originalRow, i, row) {\n            if (pivotFilters.every(function (filter) {\n              return filter(row);\n            })) {\n              return row.values[sourceColumn.id];\n            }\n          }\n        });\n      });\n    }\n\n    var uniqueValues = Array.from(pivotColumn.uniqueValues).sort();\n    return uniqueValues.map(function (uniqueValue) {\n      var columnGroup = _extends({}, pivotColumn, {\n        Header: pivotColumn.PivotHeader || typeof pivotColumn.header === 'string' ? pivotColumn.Header + \": \" + uniqueValue : uniqueValue,\n        isPivotGroup: true,\n        parent: parent,\n        depth: depth,\n        id: parent ? parent.id + \".\" + pivotColumn.id + \".\" + uniqueValue : pivotColumn.id + \".\" + uniqueValue,\n        pivotValue: uniqueValue\n      });\n\n      columnGroup.columns = buildPivotColumns(depth + 1, columnGroup, [].concat(pivotFilters, [function (row) {\n        return row.values[pivotColumn.id] === uniqueValue;\n      }]));\n      return columnGroup;\n    });\n  };\n\n  var newMaterialized = flattenColumns(buildPivotColumns());\n  return [].concat(materialized, newMaterialized);\n}\n\nfunction materializedColumnsDeps(deps, _ref5) {\n  var _ref5$instance$state = _ref5.instance.state,\n      pivotColumns = _ref5$instance$state.pivotColumns,\n      groupBy = _ref5$instance$state.groupBy;\n  return [].concat(deps, [pivotColumns, groupBy]);\n}\n\nfunction visibleColumns$1(visibleColumns, _ref6) {\n  var state = _ref6.instance.state;\n  visibleColumns = visibleColumns.filter(function (d) {\n    return !d.isPivotSource;\n  });\n\n  if (state.pivotColumns.length && state.groupBy && state.groupBy.length) {\n    visibleColumns = visibleColumns.filter(function (column) {\n      return column.isGrouped || column.isPivoted;\n    });\n  }\n\n  return visibleColumns;\n}\n\nfunction visibleColumnsDeps(deps, _ref7) {\n  var instance = _ref7.instance;\n  return [].concat(deps, [instance.state.pivotColumns, instance.state.groupBy]);\n}\n\nfunction useInstance$7(instance) {\n  var columns = instance.columns,\n      allColumns = instance.allColumns,\n      flatHeaders = instance.flatHeaders,\n      getHooks = instance.getHooks,\n      plugins = instance.plugins,\n      dispatch = instance.dispatch,\n      _instance$autoResetPi = instance.autoResetPivot,\n      autoResetPivot = _instance$autoResetPi === void 0 ? true : _instance$autoResetPi,\n      manaulPivot = instance.manaulPivot,\n      disablePivot = instance.disablePivot,\n      defaultCanPivot = instance.defaultCanPivot;\n  ensurePluginOrder(plugins, ['useGroupBy'], 'usePivotColumns');\n  var getInstance = useGetLatest(instance);\n  allColumns.forEach(function (column) {\n    var accessor = column.accessor,\n        defaultColumnPivot = column.defaultPivot,\n        columnDisablePivot = column.disablePivot;\n    column.canPivot = accessor ? getFirstDefined(column.canPivot, columnDisablePivot === true ? false : undefined, disablePivot === true ? false : undefined, true) : getFirstDefined(column.canPivot, defaultColumnPivot, defaultCanPivot, false);\n\n    if (column.canPivot) {\n      column.togglePivot = function () {\n        return instance.togglePivot(column.id);\n      };\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell;\n  });\n\n  var togglePivot = function togglePivot(columnId, value) {\n    dispatch({\n      type: actions.togglePivot,\n      columnId: columnId,\n      value: value\n    });\n  };\n\n  flatHeaders.forEach(function (header) {\n    header.getPivotToggleProps = makePropGetter(getHooks().getPivotToggleProps, {\n      instance: getInstance(),\n      header: header\n    });\n  });\n  var getAutoResetPivot = useGetLatest(autoResetPivot);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetPivot()) {\n      dispatch({\n        type: actions.resetPivot\n      });\n    }\n  }, [dispatch, manaulPivot ? null : columns]);\n  Object.assign(instance, {\n    togglePivot: togglePivot\n  });\n}\n\nfunction prepareRow$2(row) {\n  row.allCells.forEach(function (cell) {\n    // Grouped cells are in the pivotColumns and the pivot cell for the row\n    cell.isPivoted = cell.column.isPivoted;\n  });\n}\n\nvar pluginName$1 = 'useRowSelect'; // Actions\n\nactions.resetSelectedRows = 'resetSelectedRows';\nactions.toggleAllRowsSelected = 'toggleAllRowsSelected';\nactions.toggleRowSelected = 'toggleRowSelected';\n\nvar useRowSelect = function useRowSelect(hooks) {\n  hooks.getToggleRowSelectedProps = [defaultGetToggleRowSelectedProps];\n  hooks.getToggleAllRowsSelectedProps = [defaultGetToggleAllRowsSelectedProps];\n  hooks.stateReducers.push(reducer$8);\n  hooks.useInstance.push(useInstance$8);\n  hooks.prepareRow.push(prepareRow$3);\n};\n\nuseRowSelect.pluginName = pluginName$1;\n\nvar defaultGetToggleRowSelectedProps = function defaultGetToggleRowSelectedProps(props, _ref) {\n  var instance = _ref.instance,\n      row = _ref.row;\n  var _instance$manualRowSe = instance.manualRowSelectedKey,\n      manualRowSelectedKey = _instance$manualRowSe === void 0 ? 'isSelected' : _instance$manualRowSe;\n  var checked = false;\n\n  if (row.original && row.original[manualRowSelectedKey]) {\n    checked = true;\n  } else {\n    checked = row.isSelected;\n  }\n\n  return [props, {\n    onChange: function onChange(e) {\n      row.toggleRowSelected(e.target.checked);\n    },\n    style: {\n      cursor: 'pointer'\n    },\n    checked: checked,\n    title: 'Toggle Row Selected',\n    indeterminate: row.isSomeSelected\n  }];\n};\n\nvar defaultGetToggleAllRowsSelectedProps = function defaultGetToggleAllRowsSelectedProps(props, _ref2) {\n  var instance = _ref2.instance;\n  return [props, {\n    onChange: function onChange(e) {\n      instance.toggleAllRowsSelected(e.target.checked);\n    },\n    style: {\n      cursor: 'pointer'\n    },\n    checked: instance.isAllRowsSelected,\n    title: 'Toggle All Rows Selected',\n    indeterminate: Boolean(!instance.isAllRowsSelected && Object.keys(instance.state.selectedRowIds).length)\n  }];\n};\n\nfunction reducer$8(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      selectedRowIds: {}\n    }, state);\n  }\n\n  if (action.type === actions.resetSelectedRows) {\n    return _extends({}, state, {\n      selectedRowIds: instance.initialState.selectedRowIds || {}\n    });\n  }\n\n  if (action.type === actions.toggleAllRowsSelected) {\n    var setSelected = action.value;\n    var isAllRowsSelected = instance.isAllRowsSelected,\n        rowsById = instance.rowsById,\n        _instance$nonGroupedR = instance.nonGroupedRowsById,\n        nonGroupedRowsById = _instance$nonGroupedR === void 0 ? rowsById : _instance$nonGroupedR;\n    var selectAll = typeof setSelected !== 'undefined' ? setSelected : !isAllRowsSelected;\n\n    if (selectAll) {\n      var selectedRowIds = {};\n      Object.keys(nonGroupedRowsById).forEach(function (rowId) {\n        selectedRowIds[rowId] = true;\n      });\n      return _extends({}, state, {\n        selectedRowIds: selectedRowIds\n      });\n    }\n\n    return _extends({}, state, {\n      selectedRowIds: {}\n    });\n  }\n\n  if (action.type === actions.toggleRowSelected) {\n    var id = action.id,\n        _setSelected = action.value;\n    var _rowsById = instance.rowsById,\n        _instance$selectSubRo = instance.selectSubRows,\n        selectSubRows = _instance$selectSubRo === void 0 ? true : _instance$selectSubRo; // Join the ids of deep rows\n    // to make a key, then manage all of the keys\n    // in a flat object\n\n    var row = _rowsById[id];\n    var isSelected = row.isSelected;\n    var shouldExist = typeof _setSelected !== 'undefined' ? _setSelected : !isSelected;\n\n    if (isSelected === shouldExist) {\n      return state;\n    }\n\n    var newSelectedRowIds = _extends({}, state.selectedRowIds);\n\n    var handleRowById = function handleRowById(id) {\n      var row = _rowsById[id];\n\n      if (!row.isGrouped) {\n        if (!isSelected && shouldExist) {\n          newSelectedRowIds[id] = true;\n        } else if (isSelected && !shouldExist) {\n          delete newSelectedRowIds[id];\n        }\n      }\n\n      if (selectSubRows && row.subRows) {\n        return row.subRows.forEach(function (row) {\n          return handleRowById(row.id);\n        });\n      }\n    };\n\n    handleRowById(id);\n    return _extends({}, state, {\n      selectedRowIds: newSelectedRowIds\n    });\n  }\n}\n\nfunction useInstance$8(instance) {\n  var data = instance.data,\n      rows = instance.rows,\n      getHooks = instance.getHooks,\n      plugins = instance.plugins,\n      rowsById = instance.rowsById,\n      _instance$nonGroupedR2 = instance.nonGroupedRowsById,\n      nonGroupedRowsById = _instance$nonGroupedR2 === void 0 ? rowsById : _instance$nonGroupedR2,\n      _instance$autoResetSe = instance.autoResetSelectedRows,\n      autoResetSelectedRows = _instance$autoResetSe === void 0 ? true : _instance$autoResetSe,\n      selectedRowIds = instance.state.selectedRowIds,\n      _instance$selectSubRo2 = instance.selectSubRows,\n      selectSubRows = _instance$selectSubRo2 === void 0 ? true : _instance$selectSubRo2,\n      dispatch = instance.dispatch;\n  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy'], 'useRowSelect');\n  var selectedFlatRows = React.useMemo(function () {\n    var selectedFlatRows = [];\n    rows.forEach(function (row) {\n      var isSelected = selectSubRows ? getRowIsSelected(row, selectedRowIds) : !!selectedRowIds[row.id];\n      row.isSelected = !!isSelected;\n      row.isSomeSelected = isSelected === null;\n\n      if (isSelected) {\n        selectedFlatRows.push(row);\n      }\n    });\n    return selectedFlatRows;\n  }, [rows, selectSubRows, selectedRowIds]);\n  var isAllRowsSelected = Boolean(Object.keys(nonGroupedRowsById).length && Object.keys(selectedRowIds).length);\n\n  if (isAllRowsSelected) {\n    if (Object.keys(nonGroupedRowsById).some(function (id) {\n      return !selectedRowIds[id];\n    })) {\n      isAllRowsSelected = false;\n    }\n  }\n\n  var getAutoResetSelectedRows = useGetLatest(autoResetSelectedRows);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetSelectedRows()) {\n      dispatch({\n        type: actions.resetSelectedRows\n      });\n    }\n  }, [dispatch, data]);\n  var toggleAllRowsSelected = React.useCallback(function (value) {\n    return dispatch({\n      type: actions.toggleAllRowsSelected,\n      value: value\n    });\n  }, [dispatch]);\n  var toggleRowSelected = React.useCallback(function (id, value) {\n    return dispatch({\n      type: actions.toggleRowSelected,\n      id: id,\n      value: value\n    });\n  }, [dispatch]);\n  var getInstance = useGetLatest(instance);\n  var getToggleAllRowsSelectedProps = makePropGetter(getHooks().getToggleAllRowsSelectedProps, {\n    instance: getInstance()\n  });\n  Object.assign(instance, {\n    selectedFlatRows: selectedFlatRows,\n    isAllRowsSelected: isAllRowsSelected,\n    toggleRowSelected: toggleRowSelected,\n    toggleAllRowsSelected: toggleAllRowsSelected,\n    getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps\n  });\n}\n\nfunction prepareRow$3(row, _ref3) {\n  var instance = _ref3.instance;\n\n  row.toggleRowSelected = function (set) {\n    return instance.toggleRowSelected(row.id, set);\n  };\n\n  row.getToggleRowSelectedProps = makePropGetter(instance.getHooks().getToggleRowSelectedProps, {\n    instance: instance,\n    row: row\n  });\n}\n\nfunction getRowIsSelected(row, selectedRowIds) {\n  if (selectedRowIds[row.id]) {\n    return true;\n  }\n\n  if (row.subRows && row.subRows.length) {\n    var allChildrenSelected = true;\n    var someSelected = false;\n    row.subRows.forEach(function (subRow) {\n      // Bail out early if we know both of these\n      if (someSelected && !allChildrenSelected) {\n        return;\n      }\n\n      if (getRowIsSelected(subRow, selectedRowIds)) {\n        someSelected = true;\n      } else {\n        allChildrenSelected = false;\n      }\n    });\n    return allChildrenSelected ? true : someSelected ? null : false;\n  }\n\n  return false;\n}\n\nvar defaultInitialRowStateAccessor = function defaultInitialRowStateAccessor(originalRow) {\n  return {};\n};\n\nvar defaultInitialCellStateAccessor = function defaultInitialCellStateAccessor(originalRow) {\n  return {};\n}; // Actions\n\n\nactions.setRowState = 'setRowState';\nactions.setCellState = 'setCellState';\nactions.resetRowState = 'resetRowState';\n\nvar useRowState = function useRowState(hooks) {\n  hooks.stateReducers.push(reducer$9);\n  hooks.useInstance.push(useInstance$9);\n  hooks.prepareRow.push(prepareRow$4);\n};\n\nuseRowState.pluginName = 'useRowState';\n\nfunction reducer$9(state, action, previousState, instance) {\n  var _instance$initialRowS = instance.initialRowStateAccessor,\n      initialRowStateAccessor = _instance$initialRowS === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS,\n      _instance$initialCell = instance.initialCellStateAccessor,\n      initialCellStateAccessor = _instance$initialCell === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell,\n      rowsById = instance.rowsById;\n\n  if (action.type === actions.init) {\n    return _extends({\n      rowState: {}\n    }, state);\n  }\n\n  if (action.type === actions.resetRowState) {\n    return _extends({}, state, {\n      rowState: instance.initialState.rowState || {}\n    });\n  }\n\n  if (action.type === actions.setRowState) {\n    var _extends2;\n\n    var rowId = action.rowId,\n        value = action.value;\n    var oldRowState = typeof state.rowState[rowId] !== 'undefined' ? state.rowState[rowId] : initialRowStateAccessor(rowsById[rowId].original);\n    return _extends({}, state, {\n      rowState: _extends({}, state.rowState, (_extends2 = {}, _extends2[rowId] = functionalUpdate(value, oldRowState), _extends2))\n    });\n  }\n\n  if (action.type === actions.setCellState) {\n    var _oldRowState$cellStat, _extends3, _extends4;\n\n    var _rowId = action.rowId,\n        columnId = action.columnId,\n        _value = action.value;\n\n    var _oldRowState = typeof state.rowState[_rowId] !== 'undefined' ? state.rowState[_rowId] : initialRowStateAccessor(rowsById[_rowId].original);\n\n    var oldCellState = typeof (_oldRowState == null ? void 0 : (_oldRowState$cellStat = _oldRowState.cellState) == null ? void 0 : _oldRowState$cellStat[columnId]) !== 'undefined' ? _oldRowState.cellState[columnId] : initialCellStateAccessor(rowsById[_rowId].original);\n    return _extends({}, state, {\n      rowState: _extends({}, state.rowState, (_extends4 = {}, _extends4[_rowId] = _extends({}, _oldRowState, {\n        cellState: _extends({}, _oldRowState.cellState || {}, (_extends3 = {}, _extends3[columnId] = functionalUpdate(_value, oldCellState), _extends3))\n      }), _extends4))\n    });\n  }\n}\n\nfunction useInstance$9(instance) {\n  var _instance$autoResetRo = instance.autoResetRowState,\n      autoResetRowState = _instance$autoResetRo === void 0 ? true : _instance$autoResetRo,\n      data = instance.data,\n      dispatch = instance.dispatch;\n  var setRowState = React.useCallback(function (rowId, value) {\n    return dispatch({\n      type: actions.setRowState,\n      rowId: rowId,\n      value: value\n    });\n  }, [dispatch]);\n  var setCellState = React.useCallback(function (rowId, columnId, value) {\n    return dispatch({\n      type: actions.setCellState,\n      rowId: rowId,\n      columnId: columnId,\n      value: value\n    });\n  }, [dispatch]);\n  var getAutoResetRowState = useGetLatest(autoResetRowState);\n  useMountedLayoutEffect(function () {\n    if (getAutoResetRowState()) {\n      dispatch({\n        type: actions.resetRowState\n      });\n    }\n  }, [data]);\n  Object.assign(instance, {\n    setRowState: setRowState,\n    setCellState: setCellState\n  });\n}\n\nfunction prepareRow$4(row, _ref) {\n  var instance = _ref.instance;\n  var _instance$initialRowS2 = instance.initialRowStateAccessor,\n      initialRowStateAccessor = _instance$initialRowS2 === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS2,\n      _instance$initialCell2 = instance.initialCellStateAccessor,\n      initialCellStateAccessor = _instance$initialCell2 === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell2,\n      rowState = instance.state.rowState;\n\n  if (row.original) {\n    row.state = typeof rowState[row.id] !== 'undefined' ? rowState[row.id] : initialRowStateAccessor(row.original);\n\n    row.setState = function (updater) {\n      return instance.setRowState(row.id, updater);\n    };\n\n    row.cells.forEach(function (cell) {\n      if (!row.state.cellState) {\n        row.state.cellState = {};\n      }\n\n      cell.state = typeof row.state.cellState[cell.column.id] !== 'undefined' ? row.state.cellState[cell.column.id] : initialCellStateAccessor(row.original);\n\n      cell.setState = function (updater) {\n        return instance.setCellState(row.id, cell.column.id, updater);\n      };\n    });\n  }\n}\n\nactions.resetColumnOrder = 'resetColumnOrder';\nactions.setColumnOrder = 'setColumnOrder';\n\nvar useColumnOrder = function useColumnOrder(hooks) {\n  hooks.stateReducers.push(reducer$a);\n  hooks.visibleColumnsDeps.push(function (deps, _ref) {\n    var instance = _ref.instance;\n    return [].concat(deps, [instance.state.columnOrder]);\n  });\n  hooks.visibleColumns.push(visibleColumns$2);\n  hooks.useInstance.push(useInstance$a);\n};\n\nuseColumnOrder.pluginName = 'useColumnOrder';\n\nfunction reducer$a(state, action, previousState, instance) {\n  if (action.type === actions.init) {\n    return _extends({\n      columnOrder: []\n    }, state);\n  }\n\n  if (action.type === actions.resetColumnOrder) {\n    return _extends({}, state, {\n      columnOrder: instance.initialState.columnOrder || []\n    });\n  }\n\n  if (action.type === actions.setColumnOrder) {\n    return _extends({}, state, {\n      columnOrder: functionalUpdate(action.columnOrder, state.columnOrder)\n    });\n  }\n}\n\nfunction visibleColumns$2(columns, _ref2) {\n  var columnOrder = _ref2.instance.state.columnOrder; // If there is no order, return the normal columns\n\n  if (!columnOrder || !columnOrder.length) {\n    return columns;\n  }\n\n  var columnOrderCopy = [].concat(columnOrder); // If there is an order, make a copy of the columns\n\n  var columnsCopy = [].concat(columns); // And make a new ordered array of the columns\n\n  var columnsInOrder = []; // Loop over the columns and place them in order into the new array\n\n  var _loop = function _loop() {\n    var targetColumnId = columnOrderCopy.shift();\n    var foundIndex = columnsCopy.findIndex(function (d) {\n      return d.id === targetColumnId;\n    });\n\n    if (foundIndex > -1) {\n      columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);\n    }\n  };\n\n  while (columnsCopy.length && columnOrderCopy.length) {\n    _loop();\n  } // If there are any columns left, add them to the end\n\n\n  return [].concat(columnsInOrder, columnsCopy);\n}\n\nfunction useInstance$a(instance) {\n  var dispatch = instance.dispatch;\n  instance.setColumnOrder = React.useCallback(function (columnOrder) {\n    return dispatch({\n      type: actions.setColumnOrder,\n      columnOrder: columnOrder\n    });\n  }, [dispatch]);\n}\n\ndefaultColumn.canResize = true; // Actions\n\nactions.columnStartResizing = 'columnStartResizing';\nactions.columnResizing = 'columnResizing';\nactions.columnDoneResizing = 'columnDoneResizing';\n\nvar useResizeColumns = function useResizeColumns(hooks) {\n  hooks.getResizerProps = [defaultGetResizerProps];\n  hooks.getHeaderProps.push({\n    style: {\n      position: 'relative'\n    }\n  });\n  hooks.stateReducers.push(reducer$b);\n  hooks.useInstance.push(useInstance$b);\n  hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions$1);\n};\n\nvar defaultGetResizerProps = function defaultGetResizerProps(props, _ref) {\n  var instance = _ref.instance,\n      header = _ref.header;\n  var dispatch = instance.dispatch;\n\n  var onResizeStart = function onResizeStart(e, header) {\n    var isTouchEvent = false;\n\n    if (e.type === 'touchstart') {\n      // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n      if (e.touches && e.touches.length > 1) {\n        return;\n      }\n\n      isTouchEvent = true;\n    }\n\n    var headersToResize = getLeafHeaders(header);\n    var headerIdWidths = headersToResize.map(function (d) {\n      return [d.id, d.totalWidth];\n    });\n    var clientX = isTouchEvent ? Math.round(e.touches[0].clientX) : e.clientX;\n\n    var dispatchMove = function dispatchMove(clientXPos) {\n      dispatch({\n        type: actions.columnResizing,\n        clientX: clientXPos\n      });\n    };\n\n    var dispatchEnd = function dispatchEnd() {\n      return dispatch({\n        type: actions.columnDoneResizing\n      });\n    };\n\n    var handlersAndEvents = {\n      mouse: {\n        moveEvent: 'mousemove',\n        moveHandler: function moveHandler(e) {\n          return dispatchMove(e.clientX);\n        },\n        upEvent: 'mouseup',\n        upHandler: function upHandler(e) {\n          document.removeEventListener('mousemove', handlersAndEvents.mouse.moveHandler);\n          document.removeEventListener('mouseup', handlersAndEvents.mouse.upHandler);\n          dispatchEnd();\n        }\n      },\n      touch: {\n        moveEvent: 'touchmove',\n        moveHandler: function moveHandler(e) {\n          if (e.cancelable) {\n            e.preventDefault();\n            e.stopPropagation();\n          }\n\n          dispatchMove(e.touches[0].clientX);\n          return false;\n        },\n        upEvent: 'touchend',\n        upHandler: function upHandler(e) {\n          document.removeEventListener(handlersAndEvents.touch.moveEvent, handlersAndEvents.touch.moveHandler);\n          document.removeEventListener(handlersAndEvents.touch.upEvent, handlersAndEvents.touch.moveHandler);\n          dispatchEnd();\n        }\n      }\n    };\n    var events = isTouchEvent ? handlersAndEvents.touch : handlersAndEvents.mouse;\n    document.addEventListener(events.moveEvent, events.moveHandler, {\n      passive: false\n    });\n    document.addEventListener(events.upEvent, events.upHandler, {\n      passive: false\n    });\n    dispatch({\n      type: actions.columnStartResizing,\n      columnId: header.id,\n      columnWidth: header.totalWidth,\n      headerIdWidths: headerIdWidths,\n      clientX: clientX\n    });\n  };\n\n  return [props, {\n    onMouseDown: function onMouseDown(e) {\n      return e.persist() || onResizeStart(e, header);\n    },\n    onTouchStart: function onTouchStart(e) {\n      return e.persist() || onResizeStart(e, header);\n    },\n    style: {\n      cursor: 'ew-resize'\n    },\n    draggable: false,\n    role: 'separator'\n  }];\n};\n\nuseResizeColumns.pluginName = 'useResizeColumns';\n\nfunction reducer$b(state, action) {\n  if (action.type === actions.init) {\n    return _extends({\n      columnResizing: {\n        columnWidths: {}\n      }\n    }, state);\n  }\n\n  if (action.type === actions.columnStartResizing) {\n    var clientX = action.clientX,\n        columnId = action.columnId,\n        columnWidth = action.columnWidth,\n        headerIdWidths = action.headerIdWidths;\n    return _extends({}, state, {\n      columnResizing: _extends({}, state.columnResizing, {\n        startX: clientX,\n        headerIdWidths: headerIdWidths,\n        columnWidth: columnWidth,\n        isResizingColumn: columnId\n      })\n    });\n  }\n\n  if (action.type === actions.columnResizing) {\n    var _clientX = action.clientX;\n    var _state$columnResizing = state.columnResizing,\n        startX = _state$columnResizing.startX,\n        _columnWidth = _state$columnResizing.columnWidth,\n        _headerIdWidths = _state$columnResizing.headerIdWidths;\n    var deltaX = _clientX - startX;\n    var percentageDeltaX = deltaX / _columnWidth;\n    var newColumnWidths = {};\n\n    _headerIdWidths.forEach(function (_ref2) {\n      var headerId = _ref2[0],\n          headerWidth = _ref2[1];\n      newColumnWidths[headerId] = Math.max(headerWidth + headerWidth * percentageDeltaX, 0);\n    });\n\n    return _extends({}, state, {\n      columnResizing: _extends({}, state.columnResizing, {\n        columnWidths: _extends({}, state.columnResizing.columnWidths, {}, newColumnWidths)\n      })\n    });\n  }\n\n  if (action.type === actions.columnDoneResizing) {\n    return _extends({}, state, {\n      columnResizing: _extends({}, state.columnResizing, {\n        startX: null,\n        isResizingColumn: null\n      })\n    });\n  }\n}\n\nvar useInstanceBeforeDimensions$1 = function useInstanceBeforeDimensions(instance) {\n  var flatHeaders = instance.flatHeaders,\n      disableResizing = instance.disableResizing,\n      getHooks = instance.getHooks,\n      columnResizing = instance.state.columnResizing;\n  var getInstance = useGetLatest(instance);\n  flatHeaders.forEach(function (header) {\n    var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);\n    header.canResize = canResize;\n    header.width = columnResizing.columnWidths[header.id] || header.width;\n    header.isResizing = columnResizing.isResizingColumn === header.id;\n\n    if (canResize) {\n      header.getResizerProps = makePropGetter(getHooks().getResizerProps, {\n        instance: getInstance(),\n        header: header\n      });\n    }\n  });\n};\n\nfunction useInstance$b(_ref3) {\n  var plugins = _ref3.plugins;\n  ensurePluginOrder(plugins, ['useAbsoluteLayout'], 'useResizeColumns');\n}\n\nfunction getLeafHeaders(header) {\n  var leafHeaders = [];\n\n  var recurseHeader = function recurseHeader(header) {\n    if (header.columns && header.columns.length) {\n      header.columns.map(recurseHeader);\n    }\n\n    leafHeaders.push(header);\n  };\n\n  recurseHeader(header);\n  return leafHeaders;\n}\n\nvar cellStyles = {\n  position: 'absolute',\n  top: 0\n};\n\nvar useAbsoluteLayout = function useAbsoluteLayout(hooks) {\n  hooks.getTableBodyProps.push(getRowStyles);\n  hooks.getRowProps.push(getRowStyles);\n  hooks.getHeaderGroupProps.push(getRowStyles);\n  hooks.getHeaderProps.push(function (props, _ref) {\n    var column = _ref.column;\n    return [props, {\n      style: _extends({}, cellStyles, {\n        left: column.totalLeft + \"px\",\n        width: column.totalWidth + \"px\"\n      })\n    }];\n  });\n  hooks.getCellProps.push(function (props, _ref2) {\n    var cell = _ref2.cell;\n    return [props, {\n      style: _extends({}, cellStyles, {\n        left: cell.column.totalLeft + \"px\",\n        width: cell.column.totalWidth + \"px\"\n      })\n    }];\n  });\n};\n\nuseAbsoluteLayout.pluginName = 'useAbsoluteLayout';\n\nvar getRowStyles = function getRowStyles(props, _ref3) {\n  var instance = _ref3.instance;\n  return [props, {\n    style: {\n      position: 'relative',\n      width: instance.totalColumnsWidth + \"px\"\n    }\n  }];\n};\n\nvar cellStyles$1 = {\n  display: 'inline-block',\n  boxSizing: 'border-box'\n};\n\nvar getRowStyles$1 = function getRowStyles(props, _ref) {\n  var instance = _ref.instance;\n  return [props, {\n    style: {\n      display: 'flex',\n      width: instance.totalColumnsWidth + \"px\"\n    }\n  }];\n};\n\nvar useBlockLayout = function useBlockLayout(hooks) {\n  hooks.getRowProps.push(getRowStyles$1);\n  hooks.getHeaderGroupProps.push(getRowStyles$1);\n  hooks.getHeaderProps.push(function (props, _ref2) {\n    var column = _ref2.column;\n    return [props, {\n      style: _extends({}, cellStyles$1, {\n        width: column.totalWidth + \"px\"\n      })\n    }];\n  });\n  hooks.getCellProps.push(function (props, _ref3) {\n    var cell = _ref3.cell;\n    return [props, {\n      style: _extends({}, cellStyles$1, {\n        width: cell.column.totalWidth + \"px\"\n      })\n    }];\n  });\n};\n\nuseBlockLayout.pluginName = 'useBlockLayout';\n\nfunction useFlexLayout(hooks) {\n  hooks.getTableBodyProps.push(getTableBodyProps);\n  hooks.getRowProps.push(getRowStyles$2);\n  hooks.getHeaderGroupProps.push(getRowStyles$2);\n  hooks.getHeaderProps.push(getHeaderProps);\n  hooks.getCellProps.push(getCellProps);\n}\n\nuseFlexLayout.pluginName = 'useFlexLayout';\n\nvar getTableBodyProps = function getTableBodyProps(props, _ref) {\n  var instance = _ref.instance;\n  return [props, {\n    style: {\n      minWidth: instance.totalColumnsWidth + \"px\"\n    }\n  }];\n};\n\nvar getRowStyles$2 = function getRowStyles(props, _ref2) {\n  var instance = _ref2.instance;\n  return [props, {\n    style: {\n      display: 'flex',\n      flex: '1 0 auto',\n      minWidth: instance.totalColumnsMinWidth + \"px\"\n    }\n  }];\n};\n\nvar getHeaderProps = function getHeaderProps(props, _ref3) {\n  var column = _ref3.column;\n  return [props, {\n    style: {\n      boxSizing: 'border-box',\n      flex: column.totalFlexWidth ? column.totalFlexWidth + \" 0 auto\" : undefined,\n      minWidth: column.totalMinWidth + \"px\",\n      width: column.totalWidth + \"px\"\n    }\n  }];\n};\n\nvar getCellProps = function getCellProps(props, _ref4) {\n  var cell = _ref4.cell;\n  return [props, {\n    style: {\n      boxSizing: 'border-box',\n      flex: cell.column.totalFlexWidth + \" 0 auto\",\n      minWidth: cell.column.totalMinWidth + \"px\",\n      width: cell.column.totalWidth + \"px\"\n    }\n  }];\n};\n\nexport { _UNSTABLE_usePivotColumns, actions, defaultColumn, defaultGroupByFn, defaultOrderByFn, ensurePluginOrder, flexRender, functionalUpdate, loopHooks, makePropGetter, makeRenderer, reduceHooks, safeUseLayoutEffect, useAbsoluteLayout, useAsyncDebounce, useBlockLayout, useColumnOrder, useExpanded, useFilters, useFlexLayout, useGetLatest, useGlobalFilter, useGroupBy, useMountedLayoutEffect, usePagination, useResizeColumns, useRowSelect, useRowState, useSortBy, useTable };","map":null,"metadata":{},"sourceType":"module"}